"""
Î∂àÎüâ Îç∞Ïù¥ÌÑ∞ ÏãúÍ∞ÅÌôî Î™®Îìà
Teams ÏóëÏÖÄ Îç∞Ïù¥ÌÑ∞Î•º Í∏∞Î∞òÏúºÎ°ú HTML Ï∞®Ìä∏ ÏÉùÏÑ±
"""

# VS Code "Run Code" ÏßÄÏõêÏùÑ ÏúÑÌïú Í≤ΩÎ°ú ÏÑ§Ï†ï
import sys
import os

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import pandas as pd
import plotly.graph_objects as go

# import plotly.express as px  # ÏÇ¨Ïö©ÏïàÌï®
from plotly.subplots import make_subplots

# import json  # ÏÇ¨Ïö©ÏïàÌï®
import os

# from datetime import datetime  # ÏÇ¨Ïö©ÏïàÌï®
from typing import Dict  # List, Tuple ÏÇ¨Ïö©ÏïàÌï®
import io

# import numpy as np  # ÏÇ¨Ïö©ÏïàÌï®

from data.teams_loader import TeamsDataLoader
from utils.logger import setup_logger, flush_log

logger = setup_logger(__name__)


class DefectVisualizer:
    """Î∂àÎüâ Îç∞Ïù¥ÌÑ∞ ÏãúÍ∞ÅÌôî ÌÅ¥ÎûòÏä§"""

    def __init__(self):
        try:
            self.teams_loader = TeamsDataLoader()
            self.use_mock_data = False
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Teams Ïó∞Îèô Ïã§Ìå®, Mock Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©: {e}")
            self.teams_loader = None
            self.use_mock_data = True

        self.analysis_data = None
        self.defect_data = None

    def generate_colors(self, count: int) -> list:
        """ÎèôÏ†Å ÏÉâÏÉÅ ÏÉùÏÑ±"""
        base_colors = [
            "#FF6B6B",
            "#4ECDC4",
            "#45B7D1",
            "#96CEB4",
            "#FFEAA7",
            "#DDA0DD",
            "#FF8A80",
            "#81C784",
            "#64B5F6",
            "#FFB74D",
            "#F06292",
            "#9575CD",
            "#4DB6AC",
            "#AED581",
            "#FFD54F",
            "#FF8A65",
            "#A1887F",
            "#90A4AE",
        ]

        if count <= len(base_colors):
            return base_colors[:count]
        else:
            # ÏÉâÏÉÅÏù¥ Î∂ÄÏ°±ÌïòÎ©¥ HSV ÏÉâÏÉÅ Í≥µÍ∞ÑÏóêÏÑú Í∑†Îì±ÌïòÍ≤å ÏÉùÏÑ±
            import colorsys

            colors = []
            for i in range(count):
                hue = i / count
                rgb = colorsys.hsv_to_rgb(hue, 0.7, 0.9)
                hex_color = "#{:02x}{:02x}{:02x}".format(
                    int(rgb[0] * 255), int(rgb[1] * 255), int(rgb[2] * 255)
                )
                colors.append(hex_color)
            return colors

    def load_analysis_data(self) -> pd.DataFrame:
        """Î∂àÎüâÎ∂ÑÏÑù ÏõåÌÅ¨ÏãúÌä∏ Îç∞Ïù¥ÌÑ∞ Î°úÎìú"""
        try:
            logger.info("üìä Î∂àÎüâÎ∂ÑÏÑù ÏõåÌÅ¨ÏãúÌä∏ Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏãúÏûë...")

            # TeamsÏóêÏÑú ÌååÏùº Îã§Ïö¥Î°úÎìú
            files = self.teams_loader._get_teams_files()
            excel_file = self.teams_loader._find_excel_file(files)
            file_content = self.teams_loader._download_excel_file(excel_file)

            # Î∂àÎüâÎ∂ÑÏÑù ÏõåÌÅ¨ÏãúÌä∏ Î°úÎìú
            excel_buffer = io.BytesIO(file_content)
            df = pd.read_excel(excel_buffer, sheet_name="Í∞ÄÏïï Î∂àÎüâÎ∂ÑÏÑù")

            self.analysis_data = df
            logger.info(f"‚úÖ Î∂àÎüâÎ∂ÑÏÑù Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏôÑÎ£å: {df.shape}")
            flush_log(logger)

            return df

        except Exception as e:
            logger.error(f"‚ùå Î∂àÎüâÎ∂ÑÏÑù Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®: {e}")
            flush_log(logger)
            raise

    def load_defect_data(self) -> pd.DataFrame:
        """Î∂àÎüâÎÇ¥Ïó≠ ÏõåÌÅ¨ÏãúÌä∏ Îç∞Ïù¥ÌÑ∞ Î°úÎìú"""
        try:
            if self.use_mock_data:
                logger.info("üìä Mock Î∂àÎüâÎÇ¥Ïó≠ Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©...")

                # Mock Î∂àÎüâÎÇ¥Ïó≠ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
                mock_data = {
                    "Î™®Îç∏": ["Model-A", "Model-B", "Model-C"] * 20,
                    "Î∂ÄÌíàÎ™Ö": ["HEATING JACKET", "LEAK SENSOR", "TOUCH SCREEN"] * 20,
                    "Ïô∏Ï£ºÏÇ¨": ["ÏóÖÏ≤¥A", "ÏóÖÏ≤¥B", "ÏóÖÏ≤¥C"] * 20,
                    "Ï°∞Ïπò": ["Ïû¨Ï≤¥Í≤∞", "Ïû¨ÏûëÏóÖ", "Ïû¨Ï°∞Î¶Ω", "Teflon ÏûëÏóÖ", "ÌååÌä∏ÍµêÏ≤¥"]
                    * 12,
                    "ÎåÄÎ∂ÑÎ•ò": ["Í∏∞Íµ¨ÏûëÏóÖÎ∂àÎüâ", "Ï†ÑÏû•ÏûëÏóÖÎ∂àÎüâ", "Î∂ÄÌíàÎ∂àÎüâ"] * 20,
                    "Ï§ëÎ∂ÑÎ•ò": ["Ï°∞Î¶ΩÎ∂àÎüâ", "Î∞∞ÏÑ†Î∂àÎüâ", "ÌíàÏßàÎ∂àÎüâ"] * 20,
                }
                df = pd.DataFrame(mock_data)
                self.defect_data = df
                logger.info(f"‚úÖ Mock Î∂àÎüâÎÇ¥Ïó≠ Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏôÑÎ£å: {df.shape}")
                flush_log(logger)
                return df

            logger.info("üìä Î∂àÎüâÎÇ¥Ïó≠ Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏãúÏûë...")

            df = self.teams_loader.load_defect_data_from_teams()
            self.defect_data = df

            logger.info(f"‚úÖ Î∂àÎüâÎÇ¥Ïó≠ Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏôÑÎ£å: {df.shape}")
            flush_log(logger)

            return df

        except Exception as e:
            logger.error(f"‚ùå Î∂àÎüâÎÇ¥Ïó≠ Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®: {e}")
            flush_log(logger)
            raise

    def extract_monthly_data(self) -> Dict:
        """ÏõîÎ≥Ñ Î∂àÎüâ ÌòÑÌô© Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú (ÎèôÏ†Å)"""
        try:
            if self.analysis_data is None:
                self.load_analysis_data()

            # ÎèôÏ†ÅÏúºÎ°ú ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú
            months = []
            ch_counts = []
            defect_counts = []
            defect_rates = []

            # Ìó§Îçî Ìñâ Ï∞æÍ∏∞ (Íµ¨Î∂Ñ, 1Ïõî, 2Ïõî, ... ÌòïÌÉú)
            header_row = None
            for idx, row in self.analysis_data.iterrows():
                if pd.notna(row.iloc[1]) and "Íµ¨Î∂Ñ" in str(row.iloc[1]):
                    header_row = idx
                    break

            if header_row is not None:
                # ÏõîÎ≥Ñ Ïª¨Îüº Ï∞æÍ∏∞ (1Ïõî, 2Ïõî, ... ÌòïÌÉú)
                month_indices = []
                for col_idx in range(2, len(self.analysis_data.columns)):
                    cell_value = self.analysis_data.iloc[header_row, col_idx]
                    if pd.notna(cell_value) and "Ïõî" in str(cell_value):
                        months.append(str(cell_value))
                        month_indices.append(col_idx)

                # Í∞Å ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú
                for month_idx in month_indices:
                    # Í≤ÄÏÇ¨ CHÏàò Ï∞æÍ∏∞
                    ch_count = 0
                    for idx, row in self.analysis_data.iterrows():
                        if pd.notna(row.iloc[1]) and "Í≤ÄÏÇ¨ ChÏàò" in str(row.iloc[1]):
                            ch_count = (
                                row.iloc[month_idx]
                                if pd.notna(row.iloc[month_idx])
                                else 0
                            )
                            break
                    ch_counts.append(int(ch_count) if ch_count != 0 else 0)

                    # Î∂àÎüâ Í±¥Ïàò Ï∞æÍ∏∞
                    defect_count = 0
                    for idx, row in self.analysis_data.iterrows():
                        if pd.notna(row.iloc[1]) and "Î∂àÎüâ Í±¥Ïàò" in str(row.iloc[1]):
                            defect_count = (
                                row.iloc[month_idx]
                                if pd.notna(row.iloc[month_idx])
                                else 0
                            )
                            break
                    defect_counts.append(int(defect_count) if defect_count != 0 else 0)

                    # CHÎãπ Î∂àÎüâÎ•† Ï∞æÍ∏∞
                    defect_rate = 0
                    for idx, row in self.analysis_data.iterrows():
                        if pd.notna(row.iloc[1]) and "CHÎãπ Î∂àÎüâÎ•†" in str(row.iloc[1]):
                            defect_rate = (
                                row.iloc[month_idx]
                                if pd.notna(row.iloc[month_idx])
                                else 0
                            )
                            break
                    # ÏÜåÏàòÏ†ê ÌòïÌÉúÎ•º Î∞±Î∂ÑÏú®Î°ú Î≥ÄÌôò (0.318 -> 31.8)
                    defect_rates.append(
                        float(defect_rate) * 100 if defect_rate != 0 else 0
                    )

            logger.info(f"üìä ÎèôÏ†Å ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú ÏôÑÎ£å: {len(months)}Í∞úÏõî")

            return {
                "months": months,
                "ch_counts": ch_counts,
                "defect_counts": defect_counts,
                "defect_rates": defect_rates,
            }

        except Exception as e:
            logger.error(f"‚ùå ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú Ïã§Ìå®: {e}")
            flush_log(logger)
            raise

    def extract_action_type_data(self) -> Dict:
        """Î∂àÎüâÏ°∞Ïπò Ïú†ÌòïÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú (ÎèôÏ†Å)"""
        try:
            if self.analysis_data is None:
                self.load_analysis_data()

            action_types = []
            action_counts = []

            # "Î∂àÎüâÏ°∞Ïπò Ïú†ÌòïÎ≥Ñ" ÏÑπÏÖò Ï∞æÍ∏∞ (Îëê Î≤àÏß∏ Ïª¨ÎüºÏóêÏÑú)
            action_section_start = None
            for idx, row in self.analysis_data.iterrows():
                if pd.notna(row.iloc[1]) and "Î∂àÎüâÏ°∞Ïπò Ïú†ÌòïÎ≥Ñ" in str(row.iloc[1]):
                    action_section_start = idx
                    break

            if action_section_start is not None:
                # Î∂àÎüâÏ°∞Ïπò Ïú†ÌòïÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú (Îã§Ïùå ÌñâÎ∂ÄÌÑ∞ ÏãúÏûë)
                for idx in range(action_section_start + 1, len(self.analysis_data)):
                    row = self.analysis_data.iloc[idx]

                    # Îëê Î≤àÏß∏ Ïª¨ÎüºÏù¥ ÎπÑÏñ¥ÏûàÍ±∞ÎÇò Îã§Î•∏ ÏÑπÏÖòÏù¥ ÏãúÏûëÎêòÎ©¥ Ï¢ÖÎ£å
                    if pd.isna(row.iloc[1]) or "Í∏∞Íµ¨" in str(row.iloc[1]):
                        break

                    action_type = str(row.iloc[1]).strip()

                    # OÏó¥(ÎàÑÏ†ÅÍ∞í) Îç∞Ïù¥ÌÑ∞ Ï∞æÍ∏∞ - 14Î≤àÏß∏ Ïª¨Îüº (OÏó¥)
                    count = 0
                    if len(self.analysis_data.columns) > 14:  # OÏó¥Ïù¥ Ï°¥Ïû¨ÌïòÎäî Í≤ΩÏö∞
                        cell_value = row.iloc[14]  # OÏó¥ (0-based index: 14)
                        if (
                            pd.notna(cell_value)
                            and str(cell_value).replace(".", "").isdigit()
                        ):
                            count = int(float(cell_value))

                    # OÏó¥Ïóê Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏúºÎ©¥ ÎßàÏßÄÎßâ Ïª¨ÎüºÏóêÏÑú Ïó≠ÏàúÏúºÎ°ú Ï∞æÍ∏∞
                    if count == 0:
                        for col_idx in range(
                            len(self.analysis_data.columns) - 1, 1, -1
                        ):
                            cell_value = row.iloc[col_idx]
                            if (
                                pd.notna(cell_value)
                                and str(cell_value).replace(".", "").isdigit()
                            ):
                                count = int(float(cell_value))
                                break

                    if action_type and count > 0:
                        action_types.append(action_type)
                        action_counts.append(count)

            # Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏúºÎ©¥ Îçî Ï†ïÌôïÌïú Í≤ÄÏÉâÏúºÎ°ú Ïû¨ÏãúÎèÑ
            if not action_types:
                logger.warning("‚ö†Ô∏è Ï≤´ Î≤àÏß∏ ÏãúÎèÑ Ïã§Ìå®, Îçî ÎÑìÏùÄ Î≤îÏúÑÏóêÏÑú Ïû¨Í≤ÄÏÉâ...")

                # Ï†ÑÏ≤¥ ÏãúÌä∏ÏóêÏÑú "Ïû¨Ï≤¥Í≤∞", "Ïû¨ÏûëÏóÖ" Îì±Ïùò ÌÇ§ÏõåÎìúÍ∞Ä Ìè¨Ìï®Îêú Ìñâ Ï∞æÍ∏∞
                action_keywords = [
                    "Ïû¨Ï≤¥Í≤∞",
                    "Ïû¨ÏûëÏóÖ",
                    "Ïû¨Ï°∞Î¶Ω",
                    "Teflon",
                    "ÌååÌä∏ÍµêÏ≤¥",
                    "ÍµêÏ≤¥",
                    "Ï≤¥Í≤∞",
                    "ÌÅ¥Îû®ÌîÑ",
                ]

                for idx, row in self.analysis_data.iterrows():
                    for col_idx in range(len(self.analysis_data.columns)):
                        cell_value = (
                            str(row.iloc[col_idx])
                            if pd.notna(row.iloc[col_idx])
                            else ""
                        )

                        # Ï°∞Ïπò Í¥ÄÎ†® ÌÇ§ÏõåÎìúÍ∞Ä Ìè¨Ìï®ÎêòÏñ¥ ÏûàÍ≥†, Ïà´Ïûê Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏
                        for keyword in action_keywords:
                            if (
                                keyword in cell_value and len(cell_value.strip()) < 20
                            ):  # ÎÑàÎ¨¥ Í∏¥ ÌÖçÏä§Ìä∏ Ï†úÏô∏
                                # OÏó¥(14Î≤àÏß∏ Ïª¨Îüº) Ïö∞ÏÑ† ÌôïÏù∏
                                count = 0
                                if len(self.analysis_data.columns) > 14:
                                    o_col_value = row.iloc[14]  # OÏó¥
                                    if (
                                        pd.notna(o_col_value)
                                        and str(o_col_value).replace(".", "").isdigit()
                                    ):
                                        count = int(float(o_col_value))

                                # OÏó¥Ïóê ÏóÜÏúºÎ©¥ Í∞ôÏùÄ ÌñâÏóêÏÑú Ïà´Ïûê Ï∞æÍ∏∞
                                if count == 0:
                                    for count_col in range(
                                        col_idx + 1, len(self.analysis_data.columns)
                                    ):
                                        count_value = row.iloc[count_col]
                                        if (
                                            pd.notna(count_value)
                                            and str(count_value)
                                            .replace(".", "")
                                            .isdigit()
                                        ):
                                            count = int(float(count_value))
                                            break

                                if count > 0 and cell_value.strip() not in action_types:
                                    action_types.append(cell_value.strip())
                                    action_counts.append(count)
                                break

                # Ïó¨Ï†ÑÌûà Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏúºÎ©¥ Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©
                if not action_types:
                    logger.warning("‚ö†Ô∏è ÎèôÏ†Å Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú ÏôÑÏ†Ñ Ïã§Ìå®, Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©")
                    action_types = [
                        "Ïû¨Ï≤¥Í≤∞",
                        "Ïû¨Ï≤¥Í≤∞(ÌÅ¥Îû®ÌîÑ)",
                        "Ïû¨ÏûëÏóÖ",
                        "Ïû¨Ï°∞Î¶Ω",
                        "Teflon ÏûëÏóÖ",
                        "ÌååÌä∏ÍµêÏ≤¥",
                    ]
                    action_counts = [86, 11, 35, 13, 23, 124]

            logger.info(
                f"üìä ÎèôÏ†Å Î∂àÎüâÏ°∞Ïπò Ïú†Ìòï Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú ÏôÑÎ£å: {len(action_types)}Í∞ú Ïú†Ìòï"
            )

            return {"action_types": action_types, "action_counts": action_counts}

        except Exception as e:
            logger.error(f"‚ùå Ï°∞ÏπòÏú†Ìòï Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú Ïã§Ìå®: {e}")
            flush_log(logger)
            raise

    def extract_supplier_data(self) -> Dict:
        """Ïô∏Ï£ºÏÇ¨Î≥Ñ Î∂àÎüâ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú (ÎèôÏ†Å)"""
        try:
            if self.analysis_data is None:
                self.load_analysis_data()

            suppliers = []
            supplier_counts = []
            supplier_rates = []

            # "Í∏∞Íµ¨ Ïô∏Ï£ºÏÇ¨Î≥Ñ Î∂àÎüâÎ•†" ÏÑπÏÖò Ï∞æÍ∏∞
            supplier_section_start = None
            for idx, row in self.analysis_data.iterrows():
                if pd.notna(row.iloc[1]) and "Í∏∞Íµ¨ Ïô∏Ï£ºÏÇ¨Î≥Ñ Î∂àÎüâÎ•†" in str(row.iloc[1]):
                    supplier_section_start = idx
                    break

            if supplier_section_start is not None:
                # Ïô∏Ï£ºÏÇ¨Î≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú (Îã§Ïùå ÌñâÎ∂ÄÌÑ∞ ÏãúÏûë)
                idx = supplier_section_start + 1
                while idx < len(self.analysis_data):
                    row = self.analysis_data.iloc[idx]

                    # Îëê Î≤àÏß∏ Ïª¨ÎüºÏù¥ ÎπÑÏñ¥ÏûàÏúºÎ©¥ Ï¢ÖÎ£å
                    if pd.isna(row.iloc[1]):
                        break

                    supplier_name = str(row.iloc[1]).strip()

                    # Ïô∏Ï£ºÏÇ¨ Ïù¥Î¶ÑÏù¥ Ïú†Ìö®ÌïúÏßÄ ÌôïÏù∏ (BAT, FNI, TMS Îì±)
                    if (
                        supplier_name
                        and len(supplier_name) <= 5
                        and supplier_name.isalpha()
                    ):
                        # ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ìï©Í≥Ñ Í≥ÑÏÇ∞
                        total_count = 0
                        for col_idx in range(
                            2, min(len(self.analysis_data.columns), 9)
                        ):  # 1Ïõî~7Ïõî Îç∞Ïù¥ÌÑ∞
                            cell_value = row.iloc[col_idx]
                            if (
                                pd.notna(cell_value)
                                and str(cell_value).replace(".", "").isdigit()
                            ):
                                total_count += int(float(cell_value))

                        # Îã§Ïùå ÌñâÏóêÏÑú ÎπÑÏú® Ï†ïÎ≥¥ Ï∂îÏ∂ú
                        rate = 0
                        if idx + 1 < len(self.analysis_data):
                            rate_row = self.analysis_data.iloc[idx + 1]
                            # ÎπÑÏú® ÌñâÏóêÏÑú ÌèâÍ∑† Í≥ÑÏÇ∞
                            rate_values = []
                            for col_idx in range(
                                2, min(len(self.analysis_data.columns), 9)
                            ):
                                cell_value = rate_row.iloc[col_idx]
                                if pd.notna(cell_value) and isinstance(
                                    cell_value, (int, float)
                                ):
                                    rate_values.append(
                                        float(cell_value) * 100
                                    )  # Î∞±Î∂ÑÏú®Î°ú Î≥ÄÌôò
                            if rate_values:
                                rate = sum(rate_values) / len(rate_values)

                        if total_count > 0:
                            suppliers.append(supplier_name)
                            supplier_counts.append(total_count)
                            supplier_rates.append(round(rate, 1))

                        # Îã§Ïùå Ïô∏Ï£ºÏÇ¨Î°ú Ïù¥Îèô (ÎπÑÏú® Ìñâ Í±¥ÎÑàÎõ∞Í∏∞)
                        idx += 2
                    else:
                        idx += 1

            # Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏúºÎ©¥ Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©
            if not suppliers:
                logger.warning("‚ö†Ô∏è ÎèôÏ†Å Ïô∏Ï£ºÏÇ¨ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú Ïã§Ìå®, Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©")
                suppliers = ["BAT", "FNI", "TMS"]
                supplier_counts = [79, 58, 26]
                supplier_rates = [48.2, 35.4, 15.9]

            logger.info(f"üìä ÎèôÏ†Å Ïô∏Ï£ºÏÇ¨ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú ÏôÑÎ£å: {len(suppliers)}Í∞ú ÏóÖÏ≤¥")

            return {
                "suppliers": suppliers,
                "supplier_counts": supplier_counts,
                "supplier_rates": supplier_rates,
            }

        except Exception as e:
            logger.error(f"‚ùå Ïô∏Ï£ºÏÇ¨ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú Ïã§Ìå®: {e}")
            flush_log(logger)
            raise

    def extract_supplier_monthly_data(self) -> Dict:
        """Í∏∞Íµ¨ Ïô∏Ï£ºÏÇ¨Î≥Ñ ÏõîÎ≥Ñ Î∂àÎüâÎ•† Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú"""
        try:
            if self.analysis_data is None:
                self.load_analysis_data()

            # ÏõîÎ≥Ñ Ïª¨Îüº Ï∞æÍ∏∞
            months = []
            header_row = None
            for idx, row in self.analysis_data.iterrows():
                if pd.notna(row.iloc[1]) and "Íµ¨Î∂Ñ" in str(row.iloc[1]):
                    header_row = idx
                    break

            month_indices = []
            if header_row is not None:
                for col_idx in range(2, len(self.analysis_data.columns)):
                    cell_value = self.analysis_data.iloc[header_row, col_idx]
                    if pd.notna(cell_value) and "Ïõî" in str(cell_value):
                        months.append(str(cell_value))
                        month_indices.append(col_idx)

            # Í∏∞Íµ¨ Ïô∏Ï£ºÏÇ¨Î≥Ñ Î∂àÎüâÎ•† ÏÑπÏÖò Ï∞æÍ∏∞
            supplier_section_start = None
            for idx, row in self.analysis_data.iterrows():
                if pd.notna(row.iloc[1]) and "Í∏∞Íµ¨ Ïô∏Ï£ºÏÇ¨Î≥Ñ Î∂àÎüâÎ•†" in str(row.iloc[1]):
                    supplier_section_start = idx
                    break

            suppliers_monthly = {}

            if supplier_section_start is not None:
                idx = supplier_section_start + 1
                while idx < len(self.analysis_data):
                    row = self.analysis_data.iloc[idx]

                    # Îëê Î≤àÏß∏ Ïª¨ÎüºÏù¥ ÎπÑÏñ¥ÏûàÏúºÎ©¥ Ï¢ÖÎ£å
                    if pd.isna(row.iloc[1]):
                        break

                    supplier_name = str(row.iloc[1]).strip()

                    # Ïô∏Ï£ºÏÇ¨ Ïù¥Î¶ÑÏù¥ Ïú†Ìö®ÌïúÏßÄ ÌôïÏù∏ (BAT, FNI, TMS Îì±)
                    if (
                        supplier_name
                        and len(supplier_name) <= 5
                        and supplier_name.isalpha()
                    ):
                        # Îã§Ïùå ÌñâÏóêÏÑú ÏõîÎ≥Ñ ÎπÑÏú® Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú
                        if idx + 1 < len(self.analysis_data):
                            rate_row = self.analysis_data.iloc[idx + 1]
                            monthly_rates = []

                            for month_idx in month_indices:
                                cell_value = rate_row.iloc[month_idx]
                                if pd.notna(cell_value) and isinstance(
                                    cell_value, (int, float)
                                ):
                                    monthly_rates.append(
                                        float(cell_value) * 100
                                    )  # Î∞±Î∂ÑÏú®Î°ú Î≥ÄÌôò
                                else:
                                    monthly_rates.append(0)

                            suppliers_monthly[supplier_name] = monthly_rates

                        # Îã§Ïùå Ïô∏Ï£ºÏÇ¨Î°ú Ïù¥Îèô (ÎπÑÏú® Ìñâ Í±¥ÎÑàÎõ∞Í∏∞)
                        idx += 2
                    else:
                        idx += 1

            logger.info(
                f"üìä Ïô∏Ï£ºÏÇ¨Î≥Ñ ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú ÏôÑÎ£å: {len(suppliers_monthly)}Í∞ú ÏóÖÏ≤¥"
            )

            return {"months": months, "suppliers_monthly": suppliers_monthly}

        except Exception as e:
            logger.error(f"‚ùå Ïô∏Ï£ºÏÇ¨Î≥Ñ ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú Ïã§Ìå®: {e}")
            flush_log(logger)
            raise

    def extract_supplier_quarterly_data(self) -> Dict:
        """Í∏∞Íµ¨ Ïô∏Ï£ºÏÇ¨Î≥Ñ Î∂ÑÍ∏∞Î≥Ñ Î∂àÎüâÎ•† Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú"""
        try:
            # ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞Î•º Î∂ÑÍ∏∞Î≥ÑÎ°ú Í∑∏Î£πÌôî
            monthly_data = self.extract_supplier_monthly_data()

            # Î∂ÑÍ∏∞Î≥Ñ Í∑∏Î£πÌôî (1-3Ïõî: 1Î∂ÑÍ∏∞, 4-6Ïõî: 2Î∂ÑÍ∏∞, 7-9Ïõî: 3Î∂ÑÍ∏∞, 10-12Ïõî: 4Î∂ÑÍ∏∞)
            quarters = []
            suppliers_quarterly = {}

            # ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞Î•º Î∂ÑÍ∏∞Î≥ÑÎ°ú Î≥ÄÌôò
            months = monthly_data["months"]
            month_to_quarter = {}

            for month in months:
                month_num = int(month.replace("Ïõî", ""))
                if month_num in [1, 2, 3]:
                    quarter = "1Î∂ÑÍ∏∞"
                elif month_num in [4, 5, 6]:
                    quarter = "2Î∂ÑÍ∏∞"
                elif month_num in [7, 8, 9]:
                    quarter = "3Î∂ÑÍ∏∞"
                else:
                    quarter = "4Î∂ÑÍ∏∞"

                month_to_quarter[month] = quarter
                if quarter not in quarters:
                    quarters.append(quarter)

            # Í∞Å Ïô∏Ï£ºÏÇ¨Î≥ÑÎ°ú Î∂ÑÍ∏∞Î≥Ñ Îç∞Ïù¥ÌÑ∞ Í≥ÑÏÇ∞
            for supplier, monthly_rates in monthly_data["suppliers_monthly"].items():
                quarterly_rates = []

                for quarter in quarters:
                    # Ìï¥Îãπ Î∂ÑÍ∏∞Ïùò ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞ ÌèâÍ∑† Í≥ÑÏÇ∞
                    quarter_months = [
                        i
                        for i, month in enumerate(months)
                        if month_to_quarter[month] == quarter
                    ]
                    if quarter_months:
                        quarter_avg = sum(
                            monthly_rates[i] for i in quarter_months
                        ) / len(quarter_months)
                        quarterly_rates.append(round(quarter_avg, 1))
                    else:
                        quarterly_rates.append(0)

                suppliers_quarterly[supplier] = quarterly_rates

            logger.info(
                f"üìä Ïô∏Ï£ºÏÇ¨Î≥Ñ Î∂ÑÍ∏∞Î≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú ÏôÑÎ£å: {len(suppliers_quarterly)}Í∞ú ÏóÖÏ≤¥, {len(quarters)}Í∞ú Î∂ÑÍ∏∞"
            )

            return {"quarters": quarters, "suppliers_quarterly": suppliers_quarterly}

        except Exception as e:
            logger.error(f"‚ùå Ïô∏Ï£ºÏÇ¨Î≥Ñ Î∂ÑÍ∏∞Î≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú Ïã§Ìå®: {e}")
            flush_log(logger)
            raise

    def create_monthly_trend_chart(self) -> go.Figure:
        """ÏõîÎ≥Ñ Î∂àÎüâ Ìä∏Î†åÎìú Ï∞®Ìä∏ ÏÉùÏÑ±"""
        try:
            monthly_data = self.extract_monthly_data()

            # Ïù¥Ï§ë Ï∂ï Ï∞®Ìä∏ ÏÉùÏÑ±
            fig = make_subplots(
                rows=1,
                cols=1,
                specs=[[{"secondary_y": True}]],
            )

            # Í≤ÄÏÇ¨ CHÏàò (ÎßâÎåÄ Ï∞®Ìä∏)
            fig.add_trace(
                go.Bar(
                    x=monthly_data["months"],
                    y=monthly_data["ch_counts"],
                    name="Í≤ÄÏÇ¨ CHÏàò",
                    marker_color="rgba(54, 162, 235, 0.6)",
                    text=monthly_data["ch_counts"],
                    textposition="auto",
                ),
                secondary_y=False,
            )

            # Î∂àÎüâ Í±¥Ïàò (ÎßâÎåÄ Ï∞®Ìä∏)
            fig.add_trace(
                go.Bar(
                    x=monthly_data["months"],
                    y=monthly_data["defect_counts"],
                    name="Î∂àÎüâ Í±¥Ïàò",
                    marker_color="rgba(255, 99, 132, 0.8)",
                    text=monthly_data["defect_counts"],
                    textposition="auto",
                ),
                secondary_y=False,
            )

            # Î∂àÎüâÎ•† (ÏÑ† Ï∞®Ìä∏)
            fig.add_trace(
                go.Scatter(
                    x=monthly_data["months"],
                    y=monthly_data["defect_rates"],
                    mode="lines+markers",
                    name="CHÎãπ Î∂àÎüâÎ•† (%)",
                    line=dict(color="rgba(54, 162, 235, 1)", width=3),
                    marker=dict(size=8),
                    text=[f"{rate:.1f}%" for rate in monthly_data["defect_rates"]],
                    textposition="top center",
                ),
                secondary_y=True,
            )

            # Ï∂ï Ï†úÎ™© ÏÑ§Ï†ï
            fig.update_xaxes(title_text="Ïõî")
            fig.update_yaxes(
                title_text="Í±¥Ïàò (Í≤ÄÏÇ¨ CHÏàò / Î∂àÎüâ Í±¥Ïàò)", secondary_y=False
            )
            fig.update_yaxes(title_text="CHÎãπ Î∂àÎüâÎ•† (%)", secondary_y=True)

            # Î†àÏù¥ÏïÑÏõÉ ÏÑ§Ï†ï
            fig.update_layout(
                title={
                    "text": "2025ÎÖÑ Í∞ÄÏïïÍ≤ÄÏÇ¨ Î∂àÎüâ ÏõîÎ≥Ñ Ìä∏Î†åÎìú",
                    "x": 0.5,
                    "xanchor": "center",
                    "font": {"size": 20, "family": "Arial, sans-serif"},
                },
                xaxis=dict(tickangle=0, tickfont=dict(size=12)),
                legend=dict(
                    orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1
                ),
                height=500,
                template="plotly_white",
            )

            return fig

        except Exception as e:
            logger.error(f"‚ùå ÏõîÎ≥Ñ Ìä∏Î†åÎìú Ï∞®Ìä∏ ÏÉùÏÑ± Ïã§Ìå®: {e}")
            flush_log(logger)
            raise

    def create_action_type_integrated_chart_OLD_DISABLED(self) -> go.Figure:
        """Î∂àÎüâÏ°∞Ïπò Ïú†ÌòïÎ≥Ñ ÌÜµÌï© Ï∞®Ìä∏ (Î∂àÎüâÎÇ¥Ïó≠ Í∏∞Î∞ò, ÎìúÎ°≠Îã§Ïö¥ Î©îÎâ¥ Ìè¨Ìï®)"""
        try:
            logger.info("üìä Í∞ÄÏïïÍ≤ÄÏÇ¨ Ï°∞ÏπòÏú†ÌòïÎ≥Ñ ÌÜµÌï© Ï∞®Ìä∏ ÏÉùÏÑ± (Î∂àÎüâÎÇ¥Ïó≠ Í∏∞Î∞ò)")

            # Î∂àÎüâÎÇ¥Ïó≠ Îç∞Ïù¥ÌÑ∞ Î°úÎìú
            if self.defect_data is None:
                self.load_defect_data()

            df = self.defect_data.copy()
            df["Î∞úÏÉùÏùº_pd"] = pd.to_datetime(df["Î∞úÏÉùÏùº"], errors="coerce")
            df["Î∞úÏÉùÏõî"] = df["Î∞úÏÉùÏùº_pd"].dt.to_period("M")
            df["Î∞úÏÉùÎ∂ÑÍ∏∞"] = df["Î∞úÏÉùÏùº_pd"].dt.to_period("Q")

            # Ïú†Ìö®Ìïú Îç∞Ïù¥ÌÑ∞Îßå ÌïÑÌÑ∞ÎßÅ
            df_valid = df.dropna(subset=["ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©", "Î∞úÏÉùÏùº_pd"])
            logger.info(f"üìä Ïú†Ìö®Ìïú Î∂àÎüâÎÇ¥Ïó≠ Îç∞Ïù¥ÌÑ∞: {len(df_valid)}Í±¥")

            # 1. Ï†ÑÏ≤¥Î∂ÑÌè¨Ïö© Îç∞Ïù¥ÌÑ∞ (ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö© Ïπ¥Ïö¥Ìä∏)
            action_counts = df_valid["ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©"].value_counts()
            logger.info(f"üìä Ï°∞ÏπòÏú†ÌòïÎ≥Ñ Ïπ¥Ïö¥Ìä∏: {dict(action_counts.head())}")

            # 2. TOP3 Ï°∞ÏπòÏú†Ìòï Ï∂îÏ∂ú
            top_actions = action_counts.head(3).index.tolist()
            df_top3 = df_valid[df_valid["ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©"].isin(top_actions)]
            logger.info(f"üìä TOP3 Ï°∞ÏπòÏú†Ìòï: {top_actions}")

            # Î©îÏù∏ Ï∞®Ìä∏ ÏÉùÏÑ±
            fig = go.Figure()

            # ÏÉâÏÉÅ Ï†ïÏùò
            colors = [
                "#FF6B6B",
                "#4ECDC4",
                "#45B7D1",
                "#96CEB4",
                "#FFEAA7",
                "#DDA0DD",
                "#FF8A80",
                "#81C784",
            ]

            # 1. Ï†ÑÏ≤¥ Î∂ÑÌè¨ ÌååÏù¥Ï∞®Ìä∏ (ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö© Ïπ¥Ïö¥Ìä∏)
            fig.add_trace(
                go.Pie(
                    labels=action_counts.index.tolist(),
                    values=action_counts.values.tolist(),
                    hole=0.4,
                    textinfo="label+percent+value",
                    textposition="outside",
                    textfont=dict(size=12),
                    marker_colors=colors[: len(action_counts)],
                    pull=[0.05, 0, 0, 0, 0, 0.1],
                    texttemplate="%{label}<br>%{value}Í±¥ (%{percent})",
                    hovertemplate="<b>%{label}</b><br>Í±¥Ïàò: %{value}<br>ÎπÑÏú®: %{percent}<extra></extra>",
                    visible=True,  # Í∏∞Î≥∏ ÌëúÏãú
                    showlegend=True,
                    name="Ï†ÑÏ≤¥Î∂ÑÌè¨",
                )
            )

            # ÏõîÎ≥Ñ Ï°∞Ïπò Ïú†ÌòïÎ≥Ñ ÏßëÍ≥Ñ
            monthly_action = (
                df_filtered.groupby(["Î∞úÏÉùÏõî", "ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©"])
                .size()
                .unstack(fill_value=0)
            )

            # Ïõî Ïù¥Î¶ÑÏùÑ ÌïúÍµ≠Ïñ¥Î°ú Î≥ÄÌôò
            month_names = []
            for month in monthly_action.index:
                month_str = str(month)
                if "2025-01" in month_str:
                    month_names.append("1Ïõî")
                elif "2025-02" in month_str:
                    month_names.append("2Ïõî")
                elif "2025-03" in month_str:
                    month_names.append("3Ïõî")
                elif "2025-04" in month_str:
                    month_names.append("4Ïõî")
                elif "2025-05" in month_str:
                    month_names.append("5Ïõî")
                elif "2025-06" in month_str:
                    month_names.append("6Ïõî")
                elif "2025-07" in month_str:
                    month_names.append("7Ïõî")
                elif "2025-08" in month_str:
                    month_names.append("8Ïõî")
                elif "2025-09" in month_str:
                    month_names.append("9Ïõî")
                elif "2025-10" in month_str:
                    month_names.append("10Ïõî")
                elif "2025-11" in month_str:
                    month_names.append("11Ïõî")
                elif "2025-12" in month_str:
                    month_names.append("12Ïõî")
                else:
                    month_names.append(month_str)

            # 3. Î∂ÑÍ∏∞Î≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä
            df["Î∞úÏÉùÎ∂ÑÍ∏∞"] = df["Î∞úÏÉùÏùº_pd"].dt.to_period("Q")
            df_filtered_quarterly = df[df["ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©"].isin(top_actions)]
            df_filtered_quarterly = df_filtered_quarterly.dropna(subset=["Î∞úÏÉùÎ∂ÑÍ∏∞"])

            # Î∂ÑÍ∏∞Î≥Ñ Ï°∞Ïπò Ïú†ÌòïÎ≥Ñ ÏßëÍ≥Ñ
            quarterly_action = (
                df_filtered_quarterly.groupby(["Î∞úÏÉùÎ∂ÑÍ∏∞", "ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©"])
                .size()
                .unstack(fill_value=0)
            )

            # Î∂ÑÍ∏∞ Ïù¥Î¶ÑÏùÑ ÌïúÍµ≠Ïñ¥Î°ú Î≥ÄÌôò (ÎèôÏ†ÅÏúºÎ°ú Ï≤òÎ¶¨)
            quarter_names = []
            for quarter in quarterly_action.index:
                quarter_str = str(quarter)
                # Q1, Q2, Q3, Q4Î•º Í∞êÏßÄÌïòÏó¨ Î≥ÄÌôò
                if "Q1" in quarter_str:
                    quarter_names.append("1Î∂ÑÍ∏∞")
                elif "Q2" in quarter_str:
                    quarter_names.append("2Î∂ÑÍ∏∞")
                elif "Q3" in quarter_str:
                    quarter_names.append("3Î∂ÑÍ∏∞")
                elif "Q4" in quarter_str:
                    quarter_names.append("4Î∂ÑÍ∏∞")
                else:
                    quarter_names.append(quarter_str)

            # Î©îÏù∏ Ï∞®Ìä∏ ÏÉùÏÑ±
            fig = go.Figure()

            # ÏÉâÏÉÅ Ï†ïÏùò
            colors = self.generate_colors(len(action_data["action_types"]))
            monthly_colors = ["#FF6B6B", "#4ECDC4", "#45B7D1"]

            # 1. Ï†ÑÏ≤¥ Î∂ÑÌè¨ ÎèÑÎÑõÏ∞®Ìä∏ (Í∏∞Î≥∏ ÌëúÏãú, Ï†ÑÏ≤¥ Í≥µÍ∞Ñ ÌôúÏö©)
            fig.add_trace(
                go.Pie(
                    labels=action_data["action_types"],
                    values=action_data["action_counts"],
                    hole=0.4,
                    textinfo="label+percent+value",
                    textposition="outside",
                    textfont=dict(size=12),
                    marker_colors=colors,
                    pull=[0.05, 0, 0, 0, 0, 0.1],
                    texttemplate="%{label}<br>%{value}Í±¥ (%{percent})",
                    hovertemplate="<b>%{label}</b><br>Í±¥Ïàò: %{value}<br>ÎπÑÏú®: %{percent}<extra></extra>",
                    visible=True,
                    showlegend=True,
                )
            )

            # 2. ÏõîÎ≥Ñ TOP3 ÎùºÏù∏Ï∞®Ìä∏ (Ïà®ÍπÄ)
            for i, action in enumerate(top_actions):
                if action in monthly_action.columns:
                    # Ìï¥Îãπ Ï°∞Ïπò Ïú†ÌòïÏùò Î∂ÄÌíàÎ≥Ñ Ï†ïÎ≥¥ ÏàòÏßë
                    action_parts_info = []
                    for j, month in enumerate(monthly_action.index):
                        month_name = month_names[j]
                        month_count = monthly_action.loc[month, action]

                        if month_count > 0:
                            # Ìï¥Îãπ Ïõî, Ìï¥Îãπ Ï°∞Ïπò Ïú†ÌòïÏùò Î∂ÄÌíàÎì§ Ï∂îÏ∂ú
                            month_action_df = df_filtered[
                                (df_filtered["Î∞úÏÉùÏõî"] == month)
                                & (df_filtered["ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©"] == action)
                            ]

                            # Î∂ÄÌíàÎ≥Ñ Í±¥Ïàò ÏßëÍ≥Ñ
                            part_counts = month_action_df["Î∂ÄÌíàÎ™Ö"].value_counts()

                            # hover text ÏÉùÏÑ±
                            hover_text = f"<b>{month_name}: {action}</b><br>"
                            hover_text += f"Ï¥ù {month_count}Í±¥<br><br>"

                            if len(part_counts) > 0:
                                hover_text += "<b>Ï£ºÏöî Î∂ÄÌíà:</b><br>"
                                for k, (part, count) in enumerate(
                                    part_counts.head(5).items(), 1
                                ):
                                    hover_text += f"{k}. {part}: {count}Í±¥<br>"

                            action_parts_info.append(hover_text)
                        else:
                            action_parts_info.append(
                                f"<b>{month_names[j]}: {action}</b><br>0Í±¥"
                            )

                    fig.add_trace(
                        go.Scatter(
                            x=month_names,
                            y=monthly_action[action],
                            mode="lines+markers",
                            name=action,
                            line=dict(
                                color=monthly_colors[i % len(monthly_colors)], width=3
                            ),
                            marker=dict(
                                size=8, color=monthly_colors[i % len(monthly_colors)]
                            ),
                            text=[
                                f"{count}Í±¥" if count > 0 else ""
                                for count in monthly_action[action]
                            ],
                            textposition="top center",
                            textfont=dict(size=10),
                            hovertemplate="%{hovertext}<extra></extra>",
                            hovertext=action_parts_info,
                            visible=False,  # Í∏∞Î≥∏ Ïà®ÍπÄ
                        )
                    )

            # 3. Î∂ÑÍ∏∞Î≥Ñ TOP3 ÎßâÎåÄÏ∞®Ìä∏ (Ïà®ÍπÄ)
            for i, action in enumerate(top_actions):
                if action in quarterly_action.columns:
                    # Ìï¥Îãπ Ï°∞Ïπò Ïú†ÌòïÏùò Î∂ÄÌíàÎ≥Ñ Ï†ïÎ≥¥ ÏàòÏßë
                    action_parts_info = []
                    for j, quarter in enumerate(quarterly_action.index):
                        quarter_name = quarter_names[j]
                        quarter_count = quarterly_action.loc[quarter, action]

                        if quarter_count > 0:
                            # Ìï¥Îãπ Î∂ÑÍ∏∞, Ìï¥Îãπ Ï°∞Ïπò Ïú†ÌòïÏùò Î∂ÄÌíàÎì§ Ï∂îÏ∂ú
                            quarter_action_df = df_filtered_quarterly[
                                (df_filtered_quarterly["Î∞úÏÉùÎ∂ÑÍ∏∞"] == quarter)
                                & (df_filtered_quarterly["ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©"] == action)
                            ]

                            # Î∂ÄÌíàÎ≥Ñ Í±¥Ïàò ÏßëÍ≥Ñ
                            part_counts = quarter_action_df["Î∂ÄÌíàÎ™Ö"].value_counts()

                            # hover text ÏÉùÏÑ±
                            hover_text = f"<b>{quarter_name}: {action}</b><br>"
                            hover_text += f"Ï¥ù {quarter_count}Í±¥<br><br>"

                            if len(part_counts) > 0:
                                hover_text += "<b>Ï£ºÏöî Î∂ÄÌíà:</b><br>"
                                for k, (part, count) in enumerate(
                                    part_counts.head(5).items(), 1
                                ):
                                    hover_text += f"{k}. {part}: {count}Í±¥<br>"

                            action_parts_info.append(hover_text)
                        else:
                            action_parts_info.append(
                                f"<b>{quarter_names[j]}: {action}</b><br>0Í±¥"
                            )

                    fig.add_trace(
                        go.Bar(
                            x=quarter_names,
                            y=quarterly_action[action],
                            name=action,
                            marker_color=monthly_colors[i % len(monthly_colors)],
                            text=quarterly_action[action],
                            textposition="auto",
                            textfont=dict(size=10),
                            hovertemplate="%{hovertext}<extra></extra>",
                            hovertext=action_parts_info,
                            visible=False,  # Í∏∞Î≥∏ Ïà®ÍπÄ
                        )
                    )

            # ÎìúÎ°≠Îã§Ïö¥ Î©îÎâ¥ ÏÑ§Ï†ï
            pie_traces = 1  # ÎèÑÎÑõÏ∞®Ìä∏ 1Í∞ú
            monthly_bar_traces = len(top_actions)  # ÏõîÎ≥Ñ ÎßâÎåÄÏ∞®Ìä∏ Í∞úÏàò
            quarterly_bar_traces = len(top_actions)  # Î∂ÑÍ∏∞Î≥Ñ ÎßâÎåÄÏ∞®Ìä∏ Í∞úÏàò

            # Í∞ÄÏãúÏÑ± ÏÑ§Ï†ï
            visibility_pie = [True] + [False] * (
                monthly_bar_traces + quarterly_bar_traces
            )
            visibility_monthly = (
                [False] + [True] * monthly_bar_traces + [False] * quarterly_bar_traces
            )
            visibility_quarterly = (
                [False] + [False] * monthly_bar_traces + [True] * quarterly_bar_traces
            )

            # ÎìúÎ°≠Îã§Ïö¥ Î©îÎâ¥ Íµ¨ÏÑ±
            fig.update_layout(
                updatemenus=[
                    {
                        "buttons": [
                            {
                                "label": "Ï†ÑÏ≤¥ Î∂ÑÌè¨",
                                "method": "update",
                                "args": [
                                    {"visible": visibility_pie},
                                    {
                                        "title": {
                                            "text": "Î∂àÎüâÏ°∞Ïπò Ïú†ÌòïÎ≥Ñ Î∂ÑÌè¨",
                                            "x": 0.5,
                                            "xanchor": "center",
                                        },
                                        "xaxis": {"visible": False},
                                        "yaxis": {"visible": False},
                                    },
                                ],
                            },
                            {
                                "label": "Î∂ÑÍ∏∞Î≥Ñ ÎπÑÍµê (TOP3)",
                                "method": "update",
                                "args": [
                                    {"visible": visibility_quarterly},
                                    {
                                        "title": {
                                            "text": "Ï°∞Ïπò Ïú†ÌòïÎ≥Ñ TOP3 Î∂ÑÍ∏∞Î≥Ñ ÎπÑÍµê",
                                            "x": 0.5,
                                            "xanchor": "center",
                                        },
                                        "xaxis": {"visible": True, "title": "Î∂ÑÍ∏∞"},
                                        "yaxis": {
                                            "visible": True,
                                            "title": "Î∂àÎüâ Í±¥Ïàò",
                                        },
                                    },
                                ],
                            },
                            {
                                "label": "ÏõîÎ≥Ñ Ï∂îÏù¥ (TOP3)",
                                "method": "update",
                                "args": [
                                    {"visible": visibility_monthly},
                                    {
                                        "title": {
                                            "text": "Ï°∞Ïπò Ïú†ÌòïÎ≥Ñ TOP3 ÏõîÎ≥Ñ Ï∂îÏù¥",
                                            "x": 0.5,
                                            "xanchor": "center",
                                        },
                                        "xaxis": {"visible": True, "title": "Ïõî"},
                                        "yaxis": {
                                            "visible": True,
                                            "title": "Î∂àÎüâ Í±¥Ïàò",
                                        },
                                    },
                                ],
                            },
                        ],
                        "direction": "down",
                        "showactive": True,
                        "x": 0.1,
                        "xanchor": "left",
                        "y": 1.15,
                        "yanchor": "top",
                    }
                ]
            )

            # Í∏∞Î≥∏ Î†àÏù¥ÏïÑÏõÉ ÏÑ§Ï†ï
            fig.update_layout(
                title={
                    "text": "Î∂àÎüâÏ°∞Ïπò Ïú†ÌòïÎ≥Ñ Î∂ÑÌè¨",
                    "x": 0.5,
                    "xanchor": "center",
                    "font": {"size": 18, "family": "Arial, sans-serif"},
                },
                height=500,
                margin=dict(l=50, r=50, t=120, b=50),
                template="plotly_white",
                xaxis=dict(visible=False),
                yaxis=dict(visible=False),
                legend=dict(
                    orientation="v", yanchor="middle", y=0.5, xanchor="left", x=1.05
                ),
            )

            return fig

        except Exception as e:
            logger.error(f"‚ùå Ï°∞ÏπòÏú†Ìòï ÌÜµÌï© Ï∞®Ìä∏ ÏÉùÏÑ± Ïã§Ìå®: {e}")
            flush_log(logger)
            raise

    def create_action_type_integrated_chart(self) -> go.Figure:
        """Î∂àÎüâÏ°∞Ïπò Ïú†ÌòïÎ≥Ñ ÌÜµÌï© Ï∞®Ìä∏ (Î∂àÎüâÎÇ¥Ïó≠ Í∏∞Î∞ò, ÎìúÎ°≠Îã§Ïö¥ Î©îÎâ¥ Ìè¨Ìï®)"""
        try:
            logger.info("üìä Í∞ÄÏïïÍ≤ÄÏÇ¨ Ï°∞ÏπòÏú†ÌòïÎ≥Ñ ÌÜµÌï© Ï∞®Ìä∏ ÏÉùÏÑ± (Î∂àÎüâÎÇ¥Ïó≠ Í∏∞Î∞ò)")

            # Î∂àÎüâÎÇ¥Ïó≠ Îç∞Ïù¥ÌÑ∞ Î°úÎìú
            if self.defect_data is None:
                self.load_defect_data()

            df = self.defect_data.copy()
            df["Î∞úÏÉùÏùº_pd"] = pd.to_datetime(df["Î∞úÏÉùÏùº"], errors="coerce")
            df["Î∞úÏÉùÏõî"] = df["Î∞úÏÉùÏùº_pd"].dt.to_period("M")
            df["Î∞úÏÉùÎ∂ÑÍ∏∞"] = df["Î∞úÏÉùÏùº_pd"].dt.to_period("Q")

            # Ïú†Ìö®Ìïú Îç∞Ïù¥ÌÑ∞Îßå ÌïÑÌÑ∞ÎßÅ
            df_valid = df.dropna(subset=["ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©", "Î∞úÏÉùÏùº_pd"])
            logger.info(f"üìä Ïú†Ìö®Ìïú Î∂àÎüâÎÇ¥Ïó≠ Îç∞Ïù¥ÌÑ∞: {len(df_valid)}Í±¥")

            # Ï†ÑÏ≤¥Î∂ÑÌè¨Ïö© Îç∞Ïù¥ÌÑ∞ (ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö© Ïπ¥Ïö¥Ìä∏)
            action_counts = df_valid["ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©"].value_counts()
            logger.info(f"üìä Ï°∞ÏπòÏú†ÌòïÎ≥Ñ Ïπ¥Ïö¥Ìä∏: {dict(action_counts.head())}")

            # TOP3 Ï°∞ÏπòÏú†Ìòï Ï∂îÏ∂ú
            top_actions = action_counts.head(3).index.tolist()
            df_top3 = df_valid[df_valid["ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©"].isin(top_actions)]
            logger.info(f"üìä TOP3 Ï°∞ÏπòÏú†Ìòï: {top_actions}")

            # Î©îÏù∏ Ï∞®Ìä∏ ÏÉùÏÑ±
            fig = go.Figure()

            # ÏÉâÏÉÅ Ï†ïÏùò
            colors = [
                "#FF6B6B",
                "#4ECDC4",
                "#45B7D1",
                "#96CEB4",
                "#FFEAA7",
                "#DDA0DD",
                "#FF8A80",
                "#81C784",
            ]

            # 1. Ï†ÑÏ≤¥ Î∂ÑÌè¨ ÌååÏù¥Ï∞®Ìä∏ (Í∏∞Î≥∏ ÌëúÏãú)
            fig.add_trace(
                go.Pie(
                    labels=action_counts.index.tolist(),
                    values=action_counts.values.tolist(),
                    hole=0.4,
                    textinfo="label+percent+value",
                    textposition="outside",
                    textfont=dict(size=12),
                    marker_colors=colors[: len(action_counts)],
                    pull=[0.05, 0, 0, 0, 0, 0.1],
                    texttemplate="%{label}<br>%{value}Í±¥ (%{percent})",
                    hovertemplate="<b>%{label}</b><br>Í±¥Ïàò: %{value}<br>ÎπÑÏú®: %{percent}<extra></extra>",
                    visible=True,
                    showlegend=True,
                    name="Ï†ÑÏ≤¥Î∂ÑÌè¨",
                )
            )

            # 2. Î∂ÑÍ∏∞Î≥Ñ ÎπÑÍµê (TOP3) - ÎßâÎåÄ Ï∞®Ìä∏
            quarterly_data = (
                df_top3.groupby(["Î∞úÏÉùÎ∂ÑÍ∏∞", "ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©"])
                .size()
                .unstack(fill_value=0)
            )

            # Î∂ÑÍ∏∞ Ïù¥Î¶ÑÏùÑ ÌïúÍµ≠Ïñ¥Î°ú Î≥ÄÌôò
            quarter_names = []
            for quarter in quarterly_data.index:
                quarter_str = str(quarter)
                try:
                    year = quarter_str[:4]
                    q_num = quarter_str[-1]
                    quarter_names.append(f"{year}ÎÖÑ {q_num}Î∂ÑÍ∏∞")
                except:
                    quarter_names.append(quarter_str)

            # Î∂ÑÍ∏∞Î≥Ñ ÎπÑÍµêÏö© ÎßâÎåÄ Ï∞®Ìä∏ Ï∂îÍ∞Ä
            for i, action in enumerate(top_actions):
                if action in quarterly_data.columns:
                    # Í∞Å Î∂ÑÍ∏∞+Ï°∞ÏπòÏú†Ìòï Ï°∞Ìï©Ïùò Ï£ºÏöî Î∂ÄÌíàÎ™Ö Ï∂îÏ∂ú (hoverÏö©)
                    hover_texts = []
                    for quarter_period in quarterly_data.index:
                        quarter_data_filtered = df_top3[
                            (df_top3["Î∞úÏÉùÎ∂ÑÍ∏∞"] == quarter_period)
                            & (df_top3["ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©"] == action)
                        ]
                        top_parts = (
                            quarter_data_filtered["Î∂ÄÌíàÎ™Ö"]
                            .value_counts()
                            .head(5)
                            .index.tolist()
                        )
                        hover_text = (
                            f"Ï£ºÏöîÎ∂ÄÌíà: {', '.join(top_parts[:3])}"
                            if top_parts
                            else "Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå"
                        )
                        hover_texts.append(hover_text)

                    fig.add_trace(
                        go.Bar(
                            x=quarter_names,
                            y=quarterly_data[action].values,
                            name=action,
                            marker_color=colors[i % len(colors)],
                            hovertemplate=f"<b>{action}</b><br>"
                            + "Î∂ÑÍ∏∞: %{x}<br>"
                            + "Í±¥Ïàò: %{y}<br>"
                            + "%{customdata}<extra></extra>",
                            customdata=hover_texts,
                            visible=False,  # Í∏∞Î≥∏ Ïà®ÍπÄ
                        )
                    )

            # 3. ÏõîÎ≥Ñ Ï∂îÏù¥ (TOP3) - ÎùºÏù∏ Ï∞®Ìä∏
            monthly_data = (
                df_top3.groupby(["Î∞úÏÉùÏõî", "ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©"]).size().unstack(fill_value=0)
            )

            # Ïõî Ïù¥Î¶ÑÏùÑ ÌïúÍµ≠Ïñ¥Î°ú Î≥ÄÌôò
            month_names = []
            for month in monthly_data.index:
                month_str = str(month)
                try:
                    month_num = int(month_str.split("-")[1])
                    month_names.append(f"{month_num}Ïõî")
                except:
                    month_names.append(month_str)

            # ÏõîÎ≥Ñ Ï∂îÏù¥Ïö© ÎùºÏù∏ Ï∞®Ìä∏ Ï∂îÍ∞Ä
            for i, action in enumerate(top_actions):
                if action in monthly_data.columns:
                    fig.add_trace(
                        go.Scatter(
                            x=month_names,
                            y=monthly_data[action].values,
                            mode="lines+markers",
                            name=action,
                            line=dict(color=colors[i % len(colors)], width=3),
                            marker=dict(size=8),
                            hovertemplate=f"<b>{action}</b><br>"
                            + "Ïõî: %{x}<br>"
                            + "Í±¥Ïàò: %{y}<extra></extra>",
                            visible=False,  # Í∏∞Î≥∏ Ïà®ÍπÄ
                        )
                    )

            # ÎìúÎ°≠Îã§Ïö¥ Î©îÎâ¥ Íµ¨ÏÑ±
            dropdown_buttons = []

            # Ï†ÑÏ≤¥ Î∂ÑÌè¨ Î≤ÑÌäº
            pie_visibility = [True] + [False] * (len(fig.data) - 1)
            dropdown_buttons.append(
                dict(
                    label="Ï†ÑÏ≤¥ Î∂ÑÌè¨",
                    method="update",
                    args=[
                        {"visible": pie_visibility},
                        {
                            "title": "Í∞ÄÏïïÍ≤ÄÏÇ¨ Ï°∞ÏπòÏú†ÌòïÎ≥Ñ Ï†ÑÏ≤¥ Î∂ÑÌè¨",
                            "xaxis": {
                                "visible": False,
                                "showgrid": False,
                                "zeroline": False,
                            },
                            "yaxis": {
                                "visible": False,
                                "showgrid": False,
                                "zeroline": False,
                            },
                        },
                    ],
                )
            )

            # Î∂ÑÍ∏∞Î≥Ñ ÎπÑÍµê Î≤ÑÌäº
            quarterly_visibility = [False] + [
                True if i < len(top_actions) else False
                for i in range(len(fig.data) - 1)
            ]
            dropdown_buttons.append(
                dict(
                    label="Î∂ÑÍ∏∞Î≥Ñ ÎπÑÍµê (TOP3)",
                    method="update",
                    args=[
                        {"visible": quarterly_visibility},
                        {
                            "title": "Í∞ÄÏïïÍ≤ÄÏÇ¨ Ï°∞ÏπòÏú†ÌòïÎ≥Ñ Î∂ÑÍ∏∞Î≥Ñ ÎπÑÍµê (TOP3)",
                            "xaxis": {"title": "Î∂ÑÍ∏∞", "visible": True},
                            "yaxis": {"title": "Í±¥Ïàò", "visible": True},
                        },
                    ],
                )
            )

            # ÏõîÎ≥Ñ Ï∂îÏù¥ Î≤ÑÌäº
            monthly_visibility = [False] * (1 + len(top_actions)) + [True] * len(
                top_actions
            )
            dropdown_buttons.append(
                dict(
                    label="ÏõîÎ≥Ñ Ï∂îÏù¥ (TOP3)",
                    method="update",
                    args=[
                        {"visible": monthly_visibility},
                        {
                            "title": "Í∞ÄÏïïÍ≤ÄÏÇ¨ Ï°∞ÏπòÏú†ÌòïÎ≥Ñ ÏõîÎ≥Ñ Ï∂îÏù¥ (TOP3)",
                            "xaxis": {"title": "Ïõî", "visible": True},
                            "yaxis": {"title": "Í±¥Ïàò", "visible": True},
                        },
                    ],
                )
            )

            # Î†àÏù¥ÏïÑÏõÉ ÏÑ§Ï†ï
            fig.update_layout(
                updatemenus=[
                    {
                        "buttons": dropdown_buttons,
                        "direction": "down",
                        "showactive": True,
                        "x": 0.1,
                        "xanchor": "left",
                        "y": 1.15,
                        "yanchor": "top",
                    }
                ],
                title={
                    "text": "Í∞ÄÏïïÍ≤ÄÏÇ¨ Ï°∞ÏπòÏú†ÌòïÎ≥Ñ Ï†ÑÏ≤¥ Î∂ÑÌè¨",
                    "x": 0.5,
                    "xanchor": "center",
                    "font": {"size": 18, "family": "Arial, sans-serif"},
                },
                height=500,
                margin=dict(l=50, r=50, t=120, b=50),
                template="plotly_white",
                xaxis=dict(visible=False, showgrid=False, zeroline=False),
                yaxis=dict(visible=False, showgrid=False, zeroline=False),
                legend=dict(
                    orientation="v", yanchor="middle", y=0.5, xanchor="left", x=1.05
                ),
            )

            logger.info("‚úÖ Í∞ÄÏïïÍ≤ÄÏÇ¨ Ï°∞ÏπòÏú†ÌòïÎ≥Ñ ÌÜµÌï© Ï∞®Ìä∏ ÏÉùÏÑ± ÏôÑÎ£å (Î∂àÎüâÎÇ¥Ïó≠ Í∏∞Î∞ò)")
            return fig

        except Exception as e:
            logger.error(f"‚ùå Í∞ÄÏïïÍ≤ÄÏÇ¨ Ï°∞ÏπòÏú†ÌòïÎ≥Ñ ÌÜµÌï© Ï∞®Ìä∏ ÏÉùÏÑ± Ïã§Ìå®: {e}")
            flush_log(logger)
            raise

    def create_supplier_chart(self) -> go.Figure:
        """Ïô∏Ï£ºÏÇ¨Î≥Ñ Î∂àÎüâ Ï∞®Ìä∏ ÏÉùÏÑ±"""
        try:
            supplier_data = self.extract_supplier_data()

            # ÎßâÎåÄ Ï∞®Ìä∏ ÏÉùÏÑ±
            fig = go.Figure(
                data=[
                    go.Bar(
                        x=supplier_data["suppliers"],
                        y=supplier_data["supplier_counts"],
                        text=[
                            f"{count}Í±¥<br>({rate:.1f}%)"
                            for count, rate in zip(
                                supplier_data["supplier_counts"],
                                supplier_data["supplier_rates"],
                            )
                        ],
                        textposition="auto",
                        textfont=dict(size=14, color="white"),
                        marker_color=self.generate_colors(
                            len(supplier_data["suppliers"])
                        ),
                        marker_line=dict(width=1, color="rgba(0,0,0,0.3)"),
                    )
                ]
            )

            fig.update_layout(
                title={
                    "text": "Í∏∞Íµ¨ Ïô∏Ï£ºÏÇ¨Î≥Ñ Î∂àÎüâ ÌòÑÌô©",
                    "x": 0.5,
                    "xanchor": "center",
                    "font": {"size": 18, "family": "Arial, sans-serif"},
                },
                xaxis_title="Ïô∏Ï£ºÏÇ¨",
                yaxis_title="Î∂àÎüâ Í±¥Ïàò",
                xaxis=dict(tickfont=dict(size=12), title_font=dict(size=14)),
                yaxis=dict(tickfont=dict(size=12), title_font=dict(size=14)),
                height=450,
                margin=dict(l=50, r=50, t=80, b=50),
                template="plotly_white",
            )

            return fig

        except Exception as e:
            logger.error(f"‚ùå Ïô∏Ï£ºÏÇ¨ Ï∞®Ìä∏ ÏÉùÏÑ± Ïã§Ìå®: {e}")
            flush_log(logger)
            raise

    def create_supplier_monthly_chart(self) -> go.Figure:
        """Í∏∞Íµ¨ Ïô∏Ï£ºÏÇ¨Î≥Ñ ÏõîÎ≥Ñ Î∂àÎüâÎ•† Ï∞®Ìä∏ ÏÉùÏÑ±"""
        try:
            monthly_data = self.extract_supplier_monthly_data()

            # ÎßâÎåÄ Ï∞®Ìä∏ ÏÉùÏÑ±
            fig = go.Figure()

            # Ïô∏Ï£ºÏÇ¨Î≥Ñ ÏÉâÏÉÅ Ï†ïÏùò
            colors = [
                "#4CAF50",
                "#2196F3",
                "#FF9800",
            ]  # BAT: Ï¥àÎ°ù, FNI: ÌååÎûë, TMS: Ï£ºÌô©

            # Í∞Å Ïô∏Ï£ºÏÇ¨Î≥ÑÎ°ú ÎßâÎåÄ Ï∂îÍ∞Ä
            for i, (supplier, rates) in enumerate(
                monthly_data["suppliers_monthly"].items()
            ):
                fig.add_trace(
                    go.Bar(
                        x=monthly_data["months"],
                        y=rates,
                        name=supplier,
                        marker_color=colors[i % len(colors)],
                        text=[f"{rate:.1f}%" if rate > 0 else "" for rate in rates],
                        textposition="auto",
                        textfont=dict(size=10),
                        marker_line=dict(width=1, color="rgba(0,0,0,0.3)"),
                    )
                )

            fig.update_layout(
                title={
                    "text": "Í∏∞Íµ¨ Ïô∏Ï£ºÏÇ¨Î≥Ñ ÏõîÎ≥Ñ Î∂àÎüâÎ•†",
                    "x": 0.5,
                    "xanchor": "center",
                    "font": {"size": 18, "family": "Arial, sans-serif"},
                },
                xaxis_title="Ïõî",
                yaxis_title="Î∂àÎüâÎ•† (%)",
                xaxis=dict(tickfont=dict(size=12), title_font=dict(size=14)),
                yaxis=dict(
                    tickfont=dict(size=12),
                    title_font=dict(size=14),
                    range=[
                        0,
                        max(
                            [
                                max(rates)
                                for rates in monthly_data["suppliers_monthly"].values()
                            ]
                        )
                        * 1.1,
                    ],
                ),
                legend=dict(
                    orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1
                ),
                height=450,
                margin=dict(l=50, r=50, t=80, b=50),
                template="plotly_white",
                barmode="group",
            )

            return fig

        except Exception as e:
            logger.error(f"‚ùå Ïô∏Ï£ºÏÇ¨Î≥Ñ ÏõîÎ≥Ñ Ï∞®Ìä∏ ÏÉùÏÑ± Ïã§Ìå®: {e}")
            flush_log(logger)
            raise

    def create_supplier_quarterly_chart(self) -> go.Figure:
        """Í∏∞Íµ¨ Ïô∏Ï£ºÏÇ¨Î≥Ñ Î∂ÑÍ∏∞Î≥Ñ Î∂àÎüâÎ•† Ï∞®Ìä∏ ÏÉùÏÑ±"""
        try:
            quarterly_data = self.extract_supplier_quarterly_data()

            if not quarterly_data["suppliers_quarterly"]:
                raise ValueError("Ïô∏Ï£ºÏÇ¨Î≥Ñ Î∂ÑÍ∏∞Î≥Ñ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§")

            fig = go.Figure()

            # Ïô∏Ï£ºÏÇ¨Î≥Ñ ÏÉâÏÉÅ Ï†ïÏùò
            colors = [
                "#4CAF50",
                "#2196F3",
                "#FF9800",
            ]  # BAT: Ï¥àÎ°ù, FNI: ÌååÎûë, TMS: Ï£ºÌô©

            # Í∞Å Ïô∏Ï£ºÏÇ¨Î≥ÑÎ°ú ÎßâÎåÄ Ï∂îÍ∞Ä
            for i, (supplier, rates) in enumerate(
                quarterly_data["suppliers_quarterly"].items()
            ):
                fig.add_trace(
                    go.Bar(
                        x=quarterly_data["quarters"],
                        y=rates,
                        name=supplier,
                        marker_color=colors[i % len(colors)],
                        text=[f"{rate}%" if rate > 0 else "" for rate in rates],
                        textposition="outside",
                        textfont=dict(size=10),
                        marker_line=dict(width=1, color="rgba(0,0,0,0.3)"),
                    )
                )

            # Î†àÏù¥ÏïÑÏõÉ ÏÑ§Ï†ï
            fig.update_layout(
                title={
                    "text": "Í∏∞Íµ¨ Ïô∏Ï£ºÏÇ¨Î≥Ñ Î∂ÑÍ∏∞Î≥Ñ Î∂àÎüâÎ•†",
                    "x": 0.5,
                    "xanchor": "center",
                    "font": {"size": 18, "family": "Arial, sans-serif"},
                },
                xaxis_title="Î∂ÑÍ∏∞",
                yaxis_title="Î∂àÎüâÎ•† (%)",
                xaxis=dict(tickfont=dict(size=12), title_font=dict(size=14)),
                yaxis=dict(
                    tickfont=dict(size=12),
                    title_font=dict(size=14),
                    range=[
                        0,
                        max(
                            [
                                max(rates)
                                for rates in quarterly_data[
                                    "suppliers_quarterly"
                                ].values()
                            ]
                        )
                        * 1.1,
                    ],
                ),
                legend=dict(
                    orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1
                ),
                height=450,
                margin=dict(l=50, r=50, t=80, b=50),
                template="plotly_white",
                barmode="group",
            )

            return fig

        except Exception as e:
            logger.error(f"‚ùå Ïô∏Ï£ºÏÇ¨Î≥Ñ Î∂ÑÍ∏∞Î≥Ñ Ï∞®Ìä∏ ÏÉùÏÑ± Ïã§Ìå®: {e}")
            flush_log(logger)
            raise

    def create_supplier_integrated_chart(self) -> go.Figure:
        """Í∏∞Íµ¨ Ïô∏Ï£ºÏÇ¨Î≥Ñ ÌÜµÌï© Ï∞®Ìä∏ (ÎìúÎ°≠Îã§Ïö¥ Î©îÎâ¥ Ìè¨Ìï®)"""
        try:
            # 1. Ï†ÑÏ≤¥ ÌòÑÌô© Ï∞®Ìä∏
            supplier_data = self.extract_supplier_data()

            # 2. Î∂ÑÍ∏∞Î≥Ñ Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞
            quarterly_data = self.extract_supplier_quarterly_data()

            # 3. ÏõîÎ≥Ñ Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞
            monthly_data = self.extract_supplier_monthly_data()

            # Î©îÏù∏ Ï∞®Ìä∏ ÏÉùÏÑ± (Í∏∞Î≥∏: Ï†ÑÏ≤¥ ÌòÑÌô©)
            fig = go.Figure()

            # ÏÉâÏÉÅ Ï†ïÏùò
            colors = [
                "#4CAF50",
                "#2196F3",
                "#FF9800",
            ]  # BAT: Ï¥àÎ°ù, FNI: ÌååÎûë, TMS: Ï£ºÌô©

            # 1. Ï†ÑÏ≤¥ ÌòÑÌô© Ï∞®Ìä∏ (Í∏∞Î≥∏ ÌëúÏãú)
            for i, (supplier, count, rate) in enumerate(
                zip(
                    supplier_data["suppliers"],
                    supplier_data["supplier_counts"],
                    supplier_data["supplier_rates"],
                )
            ):
                fig.add_trace(
                    go.Bar(
                        x=[supplier],
                        y=[count],
                        name=supplier,
                        marker_color=colors[i % len(colors)],
                        text=[f"{count}Í±¥<br>({rate}%)"],
                        textposition="outside",
                        textfont=dict(size=10),
                        visible=True,  # Í∏∞Î≥∏ ÌëúÏãú
                    )
                )

            # 2. Î∂ÑÍ∏∞Î≥Ñ Ï∞®Ìä∏ (Ïà®ÍπÄ)
            for i, (supplier, rates) in enumerate(
                quarterly_data["suppliers_quarterly"].items()
            ):
                for j, (quarter, rate) in enumerate(
                    zip(quarterly_data["quarters"], rates)
                ):
                    fig.add_trace(
                        go.Bar(
                            x=[quarter],
                            y=[rate],
                            name=supplier,
                            marker_color=colors[i % len(colors)],
                            text=[f"{rate}%" if rate > 0 else ""],
                            textposition="outside",
                            textfont=dict(size=10),
                            visible=False,  # Í∏∞Î≥∏ Ïà®ÍπÄ
                            showlegend=False if j > 0 else True,  # Ï≤´ Î≤àÏß∏Îßå Î≤îÎ°Ä ÌëúÏãú
                        )
                    )

            # 3. ÏõîÎ≥Ñ Ï∞®Ìä∏ (ÏÑ† Í∑∏ÎûòÌîÑÎ°ú Î≥ÄÍ≤Ω)
            for i, (supplier, rates) in enumerate(
                monthly_data["suppliers_monthly"].items()
            ):
                fig.add_trace(
                    go.Scatter(
                        x=monthly_data["months"],
                        y=rates,
                        mode="lines+markers",
                        name=supplier,
                        line=dict(color=colors[i % len(colors)], width=3),
                        marker=dict(size=8, color=colors[i % len(colors)]),
                        text=[f"{rate:.1f}%" if rate > 0 else "" for rate in rates],
                        textposition="top center",
                        textfont=dict(size=10),
                        visible=False,  # Í∏∞Î≥∏ Ïà®ÍπÄ
                        showlegend=True,
                    )
                )

            # ÎìúÎ°≠Îã§Ïö¥ Î©îÎâ¥ ÏÑ§Ï†ï
            total_suppliers = len(supplier_data["suppliers"])
            quarterly_traces = len(quarterly_data["suppliers_quarterly"]) * len(
                quarterly_data["quarters"]
            )
            monthly_traces = len(
                monthly_data["suppliers_monthly"]
            )  # ÏÑ† Í∑∏ÎûòÌîÑÎ°ú Î≥ÄÍ≤ΩÎêòÏñ¥ Ïô∏Ï£ºÏÇ¨Î≥Ñ 1Í∞úÏî©

            # Í∞ÄÏãúÏÑ± ÏÑ§Ï†ï
            visibility_overall = [True] * total_suppliers + [False] * (
                quarterly_traces + monthly_traces
            )
            visibility_quarterly = (
                [False] * total_suppliers
                + [True] * quarterly_traces
                + [False] * monthly_traces
            )
            visibility_monthly = (
                [False] * total_suppliers
                + [False] * quarterly_traces
                + [True] * monthly_traces
            )

            # ÎìúÎ°≠Îã§Ïö¥ Î©îÎâ¥ Íµ¨ÏÑ±
            fig.update_layout(
                updatemenus=[
                    {
                        "buttons": [
                            {
                                "label": "Ï†ÑÏ≤¥ ÌòÑÌô© (ÎàÑÏ†Å)",
                                "method": "update",
                                "args": [
                                    {"visible": visibility_overall},
                                    {
                                        "title": {
                                            "text": "Í∏∞Íµ¨ Ïô∏Ï£ºÏÇ¨Î≥Ñ Î∂àÎüâ ÌòÑÌô© (ÎàÑÏ†Å)",
                                            "x": 0.5,
                                            "xanchor": "center",
                                        },
                                        "xaxis": {"title": "Ïô∏Ï£ºÏÇ¨"},
                                        "yaxis": {"title": "Î∂àÎüâ Í±¥Ïàò"},
                                    },
                                ],
                            },
                            {
                                "label": "Î∂ÑÍ∏∞Î≥Ñ ÎπÑÍµê",
                                "method": "update",
                                "args": [
                                    {"visible": visibility_quarterly},
                                    {
                                        "title": {
                                            "text": "Í∏∞Íµ¨ Ïô∏Ï£ºÏÇ¨Î≥Ñ Î∂ÑÍ∏∞Î≥Ñ Î∂àÎüâÎ•†",
                                            "x": 0.5,
                                            "xanchor": "center",
                                        },
                                        "xaxis": {"title": "Î∂ÑÍ∏∞"},
                                        "yaxis": {"title": "Î∂àÎüâÎ•† (%)"},
                                    },
                                ],
                            },
                            {
                                "label": "ÏõîÎ≥Ñ Ï∂îÏù¥",
                                "method": "update",
                                "args": [
                                    {"visible": visibility_monthly},
                                    {
                                        "title": {
                                            "text": "Í∏∞Íµ¨ Ïô∏Ï£ºÏÇ¨Î≥Ñ ÏõîÎ≥Ñ Î∂àÎüâÎ•†",
                                            "x": 0.5,
                                            "xanchor": "center",
                                        },
                                        "xaxis": {"title": "Ïõî"},
                                        "yaxis": {"title": "Î∂àÎüâÎ•† (%)"},
                                    },
                                ],
                            },
                        ],
                        "direction": "down",
                        "showactive": True,
                        "x": 0.1,
                        "xanchor": "left",
                        "y": 1.15,
                        "yanchor": "top",
                    }
                ]
            )

            # Í∏∞Î≥∏ Î†àÏù¥ÏïÑÏõÉ ÏÑ§Ï†ï
            fig.update_layout(
                title={
                    "text": "Í∏∞Íµ¨ Ïô∏Ï£ºÏÇ¨Î≥Ñ Î∂àÎüâ ÌòÑÌô© (ÎàÑÏ†Å)",
                    "x": 0.5,
                    "xanchor": "center",
                    "font": {"size": 18, "family": "Arial, sans-serif"},
                },
                xaxis_title="Ïô∏Ï£ºÏÇ¨",
                yaxis_title="Î∂àÎüâ Í±¥Ïàò",
                xaxis=dict(tickfont=dict(size=12), title_font=dict(size=14)),
                yaxis=dict(tickfont=dict(size=12), title_font=dict(size=14)),
                legend=dict(
                    orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1
                ),
                height=500,
                margin=dict(l=50, r=50, t=120, b=50),
                template="plotly_white",
                barmode="group",
            )

            return fig

        except Exception as e:
            logger.error(f"‚ùå Ïô∏Ï£ºÏÇ¨Î≥Ñ ÌÜµÌï© Ï∞®Ìä∏ ÏÉùÏÑ± Ïã§Ìå®: {e}")
            flush_log(logger)
            raise

    def create_defect_category_chart(self) -> go.Figure:
        """Î∂àÎüâ Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Ï∞®Ìä∏ ÏÉùÏÑ± (Î∂àÎüâÎÇ¥Ïó≠ Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò)"""
        try:
            if self.defect_data is None:
                self.load_defect_data()

            # ÎåÄÎ∂ÑÎ•òÎ≥Ñ Î∂àÎüâ Í±¥Ïàò ÏßëÍ≥Ñ
            category_counts = self.defect_data["ÎåÄÎ∂ÑÎ•ò"].value_counts()

            # ÏÉÅÏúÑ 10Í∞ú Ïπ¥ÌÖåÍ≥†Î¶¨Îßå ÌëúÏãú
            top_categories = category_counts.head(10)

            fig = go.Figure(
                data=[
                    go.Bar(
                        x=top_categories.index,
                        y=top_categories.values,
                        text=top_categories.values,
                        textposition="auto",
                        marker_color="rgba(255, 99, 132, 0.8)",
                    )
                ]
            )

            fig.update_layout(
                title={
                    "text": "Î∂àÎüâ ÎåÄÎ∂ÑÎ•òÎ≥Ñ ÌòÑÌô© (ÏÉÅÏúÑ 10Í∞ú)",
                    "x": 0.5,
                    "xanchor": "center",
                    "font": {"size": 18, "family": "Arial, sans-serif"},
                },
                xaxis_title="Î∂àÎüâ ÎåÄÎ∂ÑÎ•ò",
                yaxis_title="Î∂àÎüâ Í±¥Ïàò",
                xaxis=dict(tickangle=45),
                height=400,
                template="plotly_white",
            )

            return fig

        except Exception as e:
            logger.error(f"‚ùå Î∂àÎüâ Ïπ¥ÌÖåÍ≥†Î¶¨ Ï∞®Ìä∏ ÏÉùÏÑ± Ïã§Ìå®: {e}")
            flush_log(logger)
            raise

    def create_action_type_monthly_chart(self) -> go.Figure:
        """Ï°∞Ïπò Ïú†ÌòïÎ≥Ñ TOP3 ÏõîÎ≥Ñ ÏãúÍ∞ÅÌôî"""
        try:
            if self.defect_data is None:
                self.load_defect_data()

            # Îç∞Ïù¥ÌÑ∞ Ï†ÑÏ≤òÎ¶¨
            df = self.defect_data.copy()
            df["Î∞úÏÉùÏùº_pd"] = pd.to_datetime(df["Î∞úÏÉùÏùº"], errors="coerce")
            df["Î∞úÏÉùÏõî"] = df["Î∞úÏÉùÏùº_pd"].dt.to_period("M")

            # Ï°∞Ïπò Ïú†ÌòïÎ≥Ñ TOP3 Ï∂îÏ∂ú
            top_actions = df["ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©"].value_counts().head(3).index.tolist()

            # ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞ ÌïÑÌÑ∞ÎßÅ
            df_filtered = df[df["ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©"].isin(top_actions)]
            df_filtered = df_filtered.dropna(subset=["Î∞úÏÉùÏõî"])

            # ÏõîÎ≥Ñ Ï°∞Ïπò Ïú†ÌòïÎ≥Ñ ÏßëÍ≥Ñ
            monthly_action = (
                df_filtered.groupby(["Î∞úÏÉùÏõî", "ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©"])
                .size()
                .unstack(fill_value=0)
            )

            # Ïõî Ïù¥Î¶ÑÏùÑ ÌïúÍµ≠Ïñ¥Î°ú Î≥ÄÌôò
            month_names = []
            for month in monthly_action.index:
                month_str = str(month)
                if "2025-01" in month_str:
                    month_names.append("1Ïõî")
                elif "2025-02" in month_str:
                    month_names.append("2Ïõî")
                elif "2025-03" in month_str:
                    month_names.append("3Ïõî")
                elif "2025-04" in month_str:
                    month_names.append("4Ïõî")
                elif "2025-05" in month_str:
                    month_names.append("5Ïõî")
                elif "2025-06" in month_str:
                    month_names.append("6Ïõî")
                elif "2025-07" in month_str:
                    month_names.append("7Ïõî")
                elif "2025-08" in month_str:
                    month_names.append("8Ïõî")
                elif "2025-09" in month_str:
                    month_names.append("9Ïõî")
                elif "2025-10" in month_str:
                    month_names.append("10Ïõî")
                elif "2025-11" in month_str:
                    month_names.append("11Ïõî")
                elif "2025-12" in month_str:
                    month_names.append("12Ïõî")
                else:
                    month_names.append(month_str)

            # subplotÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ ÏôºÏ™ΩÏóê Î∞∞Ïπò
            from plotly.subplots import make_subplots

            fig = make_subplots(
                rows=1,
                cols=2,
                column_widths=[0.7, 0.3],  # Ï≤´ Î≤àÏß∏ Ïª¨ÎüºÏùÑ Îçî ÌÅ¨Í≤å
                specs=[[{"type": "xy"}, {"type": "xy"}]],
                subplot_titles=[
                    "Ï°∞Ïπò Ïú†ÌòïÎ≥Ñ TOP3 ÏõîÎ≥Ñ ÌòÑÌô©",
                    "",
                ],  # Ï≤´ Î≤àÏß∏ Ïª¨ÎüºÏóêÎßå Ï†úÎ™©
                horizontal_spacing=0.05,
            )

            colors = ["#FF6B6B", "#4ECDC4", "#45B7D1"]

            # Ï≤´ Î≤àÏß∏ Ïª¨ÎüºÏóê ÎßâÎåÄ Ï∞®Ìä∏ Ï∂îÍ∞Ä (ÏôºÏ™Ω Ï†ïÎ†¨)
            for i, action in enumerate(top_actions):
                if action in monthly_action.columns:
                    # Ìï¥Îãπ Ï°∞Ïπò Ïú†ÌòïÏùò Î∂ÄÌíàÎ≥Ñ Ï†ïÎ≥¥ ÏàòÏßë
                    action_parts_info = []
                    for j, month in enumerate(monthly_action.index):
                        month_name = month_names[j]
                        month_count = monthly_action.loc[month, action]

                        if month_count > 0:
                            # Ìï¥Îãπ Ïõî, Ìï¥Îãπ Ï°∞Ïπò Ïú†ÌòïÏùò Î∂ÄÌíàÎì§ Ï∂îÏ∂ú
                            month_action_df = df_filtered[
                                (df_filtered["Î∞úÏÉùÏõî"] == month)
                                & (df_filtered["ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©"] == action)
                            ]

                            # Î∂ÄÌíàÎ≥Ñ Í±¥Ïàò ÏßëÍ≥Ñ
                            part_counts = month_action_df["Î∂ÄÌíàÎ™Ö"].value_counts()

                            # hover text ÏÉùÏÑ±
                            hover_text = f"<b>{month_name}: {action}</b><br>"
                            hover_text += f"Ï¥ù {month_count}Í±¥<br><br>"

                            if len(part_counts) > 0:
                                hover_text += "<b>Ï£ºÏöî Î∂ÄÌíà:</b><br>"
                                for k, (part, count) in enumerate(
                                    part_counts.head(5).items(), 1
                                ):
                                    hover_text += f"{k}. {part}: {count}Í±¥<br>"

                            action_parts_info.append(hover_text)
                        else:
                            action_parts_info.append(
                                f"<b>{month_names[j]}: {action}</b><br>0Í±¥"
                            )

                    fig.add_trace(
                        go.Bar(
                            x=month_names,
                            y=monthly_action[action],
                            name=action,
                            marker_color=colors[i % len(colors)],
                            text=monthly_action[action],
                            textposition="auto",
                            textfont=dict(size=10),
                            hovertemplate="%{hovertext}<extra></extra>",
                            hovertext=action_parts_info,
                            showlegend=False,
                        ),
                        row=1,
                        col=1,
                    )

            # Îëê Î≤àÏß∏ Ïª¨ÎüºÏóêÎäî Î≤îÎ°Ä Ï†ïÎ≥¥Î•º ÌÖçÏä§Ìä∏Î°ú ÌëúÏãú
            legend_text = []
            total_counts = df["ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©"].value_counts()
            for i, action in enumerate(top_actions):
                count = total_counts[action] if action in total_counts else 0
                legend_text.append(
                    f"<span style='color: {colors[i % len(colors)]}; font-size: 16px;'>‚óè</span> {action}: {count}Í±¥"
                )

            # Îπà scatter plotÏúºÎ°ú Î≤îÎ°Ä ÏòÅÏó≠ ÏÉùÏÑ±
            fig.add_trace(
                go.Scatter(
                    x=[0],
                    y=[0.5],
                    mode="text",
                    text="<br>".join(legend_text),
                    textfont=dict(size=14, family="Arial"),
                    textposition="middle left",
                    showlegend=False,
                ),
                row=1,
                col=2,
            )

            # Ï≤´ Î≤àÏß∏ subplot Ï∂ï ÏÑ§Ï†ï
            fig.update_xaxes(
                title_text="Ïõî",
                tickfont=dict(size=10),
                title_font=dict(size=12),
                row=1,
                col=1,
            )
            fig.update_yaxes(
                title_text="Î∂àÎüâ Í±¥Ïàò",
                tickfont=dict(size=10),
                title_font=dict(size=12),
                row=1,
                col=1,
            )

            # Îëê Î≤àÏß∏ subplotÏùò Ï∂ï Ïà®Í∏∞Í∏∞
            fig.update_xaxes(
                showgrid=False,
                showticklabels=False,
                zeroline=False,
                visible=False,
                row=1,
                col=2,
            )
            fig.update_yaxes(
                showgrid=False,
                showticklabels=False,
                zeroline=False,
                visible=False,
                row=1,
                col=2,
            )

            fig.update_layout(
                height=450,
                margin=dict(l=10, r=10, t=80, b=50),
                template="plotly_white",
                barmode="group",
            )

            return fig

        except Exception as e:
            logger.error(f"‚ùå Ï°∞Ïπò Ïú†ÌòïÎ≥Ñ ÏõîÎ≥Ñ Ï∞®Ìä∏ ÏÉùÏÑ± Ïã§Ìå®: {e}")
            flush_log(logger)
            raise

    def create_part_monthly_chart(self) -> go.Figure:
        """ÎìúÎ°≠Îã§Ïö¥ ÌòïÌÉú Î∂ÄÌíà Î∂ÑÏÑù Ï∞®Ìä∏"""
        try:
            if self.defect_data is None:
                self.load_defect_data()

            # Îç∞Ïù¥ÌÑ∞ Ï†ÑÏ≤òÎ¶¨ - HeÎØ∏Î≥¥Ï¶ù Ï†úÏô∏
            df = self.defect_data.copy()
            df["Î∞úÏÉùÏùº_pd"] = pd.to_datetime(df["Î∞úÏÉùÏùº"], errors="coerce")
            df["Î∞úÏÉùÏõî"] = df["Î∞úÏÉùÏùº_pd"].dt.to_period("M")
            df["Î∞úÏÉùÎ∂ÑÍ∏∞"] = df["Î∞úÏÉùÏùº_pd"].dt.to_period("Q")

            # HeÎØ∏Î≥¥Ï¶ù Îç∞Ïù¥ÌÑ∞ Ï†úÏô∏
            df_filtered_he = df[
                ~df["ÎπÑÍ≥†"].str.contains("HeÎØ∏Î≥¥Ï¶ù", case=False, na=False)
            ]
            df_filtered_he = df_filtered_he.dropna(subset=["Î∞úÏÉùÎ∂ÑÍ∏∞"])

            # Î∂ÑÍ∏∞Î≥Ñ TOP5 Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú
            quarters = sorted(df_filtered_he["Î∞úÏÉùÎ∂ÑÍ∏∞"].unique())
            quarterly_top5_data = {}

            for quarter in quarters:
                quarter_df = df_filtered_he[df_filtered_he["Î∞úÏÉùÎ∂ÑÍ∏∞"] == quarter]
                quarter_top5 = quarter_df["Î∂ÄÌíàÎ™Ö"].value_counts().head(5)
                quarterly_top5_data[quarter] = quarter_top5

            # Ï†ÑÏ≤¥ Í∏∞Í∞Ñ TOP3 Î∂ÄÌíàÏùò ÏõîÎ≥Ñ Ï∂îÏù¥
            overall_top3_parts = (
                df_filtered_he["Î∂ÄÌíàÎ™Ö"].value_counts().head(3).index.tolist()
            )

            # ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú
            months = sorted(df_filtered_he["Î∞úÏÉùÏõî"].unique())
            monthly_top3_data = {}

            for month in months:
                month_df = df_filtered_he[df_filtered_he["Î∞úÏÉùÏõî"] == month]
                month_part_counts = month_df["Î∂ÄÌíàÎ™Ö"].value_counts()
                monthly_top3_data[month] = month_part_counts

            # Î∂ÑÍ∏∞ Ïù¥Î¶ÑÏùÑ ÌïúÍµ≠Ïñ¥Î°ú ÎèôÏ†Å Î≥ÄÌôò
            quarter_names = []
            for quarter in quarters:
                quarter_str = str(quarter)
                # ÎÖÑÎèÑÏôÄ Î∂ÑÍ∏∞Î•º ÎèôÏ†ÅÏúºÎ°ú Ï∂îÏ∂ú
                if "Q1" in quarter_str:
                    quarter_names.append("1Î∂ÑÍ∏∞")
                elif "Q2" in quarter_str:
                    quarter_names.append("2Î∂ÑÍ∏∞")
                elif "Q3" in quarter_str:
                    quarter_names.append("3Î∂ÑÍ∏∞")
                elif "Q4" in quarter_str:
                    quarter_names.append("4Î∂ÑÍ∏∞")
                else:
                    quarter_names.append(quarter_str)

            # Ïõî Ïù¥Î¶ÑÏùÑ ÌïúÍµ≠Ïñ¥Î°ú Î≥ÄÌôò
            month_names = []
            for month in months:
                month_str = str(month)
                if "2025-01" in month_str:
                    month_names.append("1Ïõî")
                elif "2025-02" in month_str:
                    month_names.append("2Ïõî")
                elif "2025-03" in month_str:
                    month_names.append("3Ïõî")
                elif "2025-04" in month_str:
                    month_names.append("4Ïõî")
                elif "2025-05" in month_str:
                    month_names.append("5Ïõî")
                elif "2025-06" in month_str:
                    month_names.append("6Ïõî")
                elif "2025-07" in month_str:
                    month_names.append("7Ïõî")
                elif "2025-08" in month_str:
                    month_names.append("8Ïõî")
                elif "2025-09" in month_str:
                    month_names.append("9Ïõî")
                elif "2025-10" in month_str:
                    month_names.append("10Ïõî")
                elif "2025-11" in month_str:
                    month_names.append("11Ïõî")
                elif "2025-12" in month_str:
                    month_names.append("12Ïõî")
                else:
                    month_names.append(month_str)

            # Ï∞®Ìä∏ ÏÉùÏÑ±
            fig = go.Figure()

            # ÏÉâÏÉÅ Ï†ïÏùò
            colors = ["#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", "#FFEAA7"]

            # 0. Ï†ÑÏ≤¥ Î∂ÑÌè¨ ÌååÏù¥Ï∞®Ìä∏ (TOP10 + Í∏∞ÌÉÄ)
            part_counts = df_filtered_he["Î∂ÄÌíàÎ™Ö"].value_counts()

            # TOP10 Ï∂îÏ∂ú
            top10_parts = part_counts.head(10)
            other_count = part_counts.iloc[10:].sum() if len(part_counts) > 10 else 0

            # TOP10 + Í∏∞ÌÉÄÎ°ú Íµ¨ÏÑ±
            if other_count > 0:
                pie_labels = list(top10_parts.index) + ["Í∏∞ÌÉÄ"]
                pie_values = list(top10_parts.values) + [other_count]
            else:
                pie_labels = list(top10_parts.index)
                pie_values = list(top10_parts.values)

            fig.add_trace(
                go.Pie(
                    labels=pie_labels,
                    values=pie_values,
                    hole=0.4,
                    textinfo="label+percent+value",
                    textposition="outside",
                    textfont=dict(size=12),
                    marker_colors=colors[: len(pie_labels)],
                    pull=[
                        0.05,
                        0,
                        0,
                        0,
                        0,
                        0.1,
                        0,
                        0,
                        0,
                        0,
                        0.05,
                    ],  # Ï≤´ Î≤àÏß∏ÏôÄ ÎßàÏßÄÎßâ(Í∏∞ÌÉÄ) Í∞ïÏ°∞
                    texttemplate="%{label}<br>%{value}Í±¥ (%{percent})",
                    hovertemplate="<b>%{label}</b><br>Í±¥Ïàò: %{value}<br>ÎπÑÏú®: %{percent}<extra></extra>",
                    visible=True,  # Í∏∞Î≥∏ ÌëúÏãú
                    showlegend=True,
                )
            )

            # Í∞Å Î∂ÑÍ∏∞Î≥Ñ TOP5 Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä
            for q_idx, quarter in enumerate(quarters):
                quarter_name = quarter_names[q_idx]
                top5_parts = quarterly_top5_data[quarter]

                # Í∞Å Î∂ÄÌíàÎ≥Ñ ÎßâÎåÄ Ï∂îÍ∞Ä
                for p_idx, (part, count) in enumerate(top5_parts.items()):
                    # Ìï¥Îãπ Î∂ÑÍ∏∞, Ìï¥Îãπ Î∂ÄÌíàÏùò ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Ï∂îÏ∂ú
                    quarter_part_df = df_filtered_he[
                        (df_filtered_he["Î∞úÏÉùÎ∂ÑÍ∏∞"] == quarter)
                        & (df_filtered_he["Î∂ÄÌíàÎ™Ö"] == part)
                    ]

                    # ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©Í≥º Î∂àÎüâÏúÑÏπò Ï†ïÎ≥¥ ÏàòÏßë
                    action_details = (
                        quarter_part_df["ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©"].dropna().unique()[:5]
                    )  # ÏµúÎåÄ 5Í∞ú
                    location_details = (
                        quarter_part_df["Î∂àÎüâÏúÑÏπò"].dropna().unique()[:5]
                    )  # ÏµúÎåÄ 5Í∞ú

                    # hover text ÏÉùÏÑ±
                    hover_text = f"<b>{part}</b><br>"
                    hover_text += f"Î∂àÎüâ Í±¥Ïàò: {count}Í±¥<br><br>"

                    if len(action_details) > 0:
                        hover_text += "<b>Ï£ºÏöî Ï°∞ÏπòÎÇ¥Ïö©:</b><br>"
                        for i, action in enumerate(action_details, 1):
                            hover_text += f"{i}. {action}<br>"
                        hover_text += "<br>"

                    if len(location_details) > 0:
                        hover_text += "<b>Ï£ºÏöî Î∂àÎüâÏúÑÏπò:</b><br>"
                        for i, location in enumerate(location_details, 1):
                            hover_text += f"{i}. {location}<br>"

                    fig.add_trace(
                        go.Bar(
                            x=[part],
                            y=[count],
                            name=part,
                            marker_color=colors[p_idx % len(colors)],
                            text=[count],
                            textposition="auto",
                            textfont=dict(size=12),
                            hovertemplate=f"{hover_text}<extra></extra>",
                            visible=False,  # ÌååÏù¥Ï∞®Ìä∏Í∞Ä Í∏∞Î≥∏Ïù¥ÎØÄÎ°ú Î™®Îì† ÎßâÎåÄÏ∞®Ìä∏Îäî Ïà®ÍπÄ
                            legendgroup=f"quarter_{q_idx}",
                            showlegend=False,
                        )
                    )

            # ÏõîÎ≥Ñ Ï∂îÏù¥ Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä
            for p_idx, part in enumerate(overall_top3_parts):
                x_values = []
                y_values = []
                hover_texts = []

                for j, month in enumerate(months):
                    month_name = month_names[j]
                    x_values.append(month_name)

                    if part in monthly_top3_data[month]:
                        y_values.append(monthly_top3_data[month][part])
                    else:
                        y_values.append(0)

                    # Ìï¥Îãπ Ïõî, Ìï¥Îãπ Î∂ÄÌíàÏùò ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Ï∂îÏ∂ú
                    month_part_df = df_filtered_he[
                        (df_filtered_he["Î∞úÏÉùÏõî"] == month)
                        & (df_filtered_he["Î∂ÄÌíàÎ™Ö"] == part)
                    ]

                    # ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©Í≥º Î∂àÎüâÏúÑÏπò Ï†ïÎ≥¥ ÏàòÏßë
                    action_details = (
                        month_part_df["ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©"].dropna().unique()[:3]
                    )  # ÏµúÎåÄ 3Í∞ú
                    location_details = (
                        month_part_df["Î∂àÎüâÏúÑÏπò"].dropna().unique()[:3]
                    )  # ÏµúÎåÄ 3Í∞ú

                    # hover text ÏÉùÏÑ±
                    hover_text = f"<b>{month_name}: {part}</b><br>"
                    hover_text += f"Î∂àÎüâ Í±¥Ïàò: {y_values[-1]}Í±¥<br><br>"

                    if len(action_details) > 0:
                        hover_text += "<b>Ï£ºÏöî Ï°∞ÏπòÎÇ¥Ïö©:</b><br>"
                        for i, action in enumerate(action_details, 1):
                            hover_text += f"{i}. {action}<br>"
                        hover_text += "<br>"

                    if len(location_details) > 0:
                        hover_text += "<b>Ï£ºÏöî Î∂àÎüâÏúÑÏπò:</b><br>"
                        for i, location in enumerate(location_details, 1):
                            hover_text += f"{i}. {location}<br>"

                    hover_texts.append(hover_text)

                fig.add_trace(
                    go.Scatter(
                        x=x_values,
                        y=y_values,
                        mode="lines+markers",
                        name=part,
                        line=dict(color=colors[p_idx % len(colors)], width=3),
                        marker=dict(size=8),
                        text=y_values,
                        textposition="top center",
                        textfont=dict(size=10),
                        hovertemplate="%{hovertext}<extra></extra>",
                        hovertext=hover_texts,
                        visible=False,  # Í∏∞Î≥∏Ï†ÅÏúºÎ°ú Ïà®ÍπÄ
                        legendgroup="trend",
                        showlegend=False,
                    )
                )

            # ÎìúÎ°≠Îã§Ïö¥ Î©îÎâ¥ Î≤ÑÌäº Íµ¨ÏÑ±
            dropdown_buttons = []

            # Ï†ÑÏ≤¥ Î∂ÑÌè¨ Î≤ÑÌäº (Ï≤´ Î≤àÏß∏)
            pie_visibility = [True] + [False] * (len(fig.data) - 1)  # ÌååÏù¥Ï∞®Ìä∏Îßå ÌëúÏãú
            dropdown_buttons.append(
                dict(
                    label="Ï†ÑÏ≤¥ Î∂ÑÌè¨",
                    method="update",
                    args=[
                        {"visible": pie_visibility},
                        {
                            "title": "Í∞ÄÏïïÍ≤ÄÏÇ¨ Î∂ÄÌíàÎ≥Ñ Ï†ÑÏ≤¥ Î∂ÑÌè¨ (TOP10)",
                            "xaxis": {
                                "visible": False,
                                "showgrid": False,
                                "zeroline": False,
                            },
                            "yaxis": {
                                "visible": False,
                                "showgrid": False,
                                "zeroline": False,
                            },
                        },
                    ],
                )
            )

            # Í∞Å Î∂ÑÍ∏∞Î≥Ñ Î≤ÑÌäº
            for q_idx, quarter in enumerate(quarters):
                quarter_name = quarter_names[q_idx]

                # Ìï¥Îãπ Î∂ÑÍ∏∞Ïùò traceÎßå Î≥¥Ïù¥ÎèÑÎ°ù ÏÑ§Ï†ï
                visibility = [False] * len(fig.data)
                start_idx = 1 + q_idx * 5  # ÌååÏù¥Ï∞®Ìä∏(1Í∞ú) + Í∞Å Î∂ÑÍ∏∞Îãπ 5Í∞ú Î∂ÄÌíà
                end_idx = start_idx + len(quarterly_top5_data[quarter])

                for i in range(start_idx, min(end_idx, len(fig.data))):
                    if i < len(fig.data):
                        visibility[i] = True

                dropdown_buttons.append(
                    dict(
                        label=f"{quarter_name} TOP5",
                        method="update",
                        args=[
                            {"visible": visibility},
                            {
                                "title": f"{quarter_name} TOP5 Î∂ÄÌíà Î∂àÎüâ ÌòÑÌô©",
                                "xaxis": {"title": "Î∂ÄÌíàÎ™Ö", "visible": True},
                                "yaxis": {"title": "Î∂àÎüâ Í±¥Ïàò", "visible": True},
                            },
                        ],
                    )
                )

            # ÏõîÎ≥Ñ Ï∂îÏù¥ Î≤ÑÌäº
            trend_visibility = [False] * len(fig.data)
            trend_start_idx = (
                1 + len(quarters) * 5
            )  # ÌååÏù¥Ï∞®Ìä∏(1Í∞ú) + Î∂ÑÍ∏∞Î≥Ñ Îç∞Ïù¥ÌÑ∞ Ïù¥ÌõÑ
            for i in range(trend_start_idx, len(fig.data)):
                trend_visibility[i] = True

            dropdown_buttons.append(
                dict(
                    label="ÏõîÎ≥Ñ Ï∂îÏù¥ (TOP3)",
                    method="update",
                    args=[
                        {"visible": trend_visibility},
                        {
                            "title": "Ï†ÑÏ≤¥ Í∏∞Í∞Ñ TOP3 Î∂ÄÌíà ÏõîÎ≥Ñ Ï∂îÏù¥",
                            "xaxis": {"title": "Ïõî", "visible": True},
                            "yaxis": {"title": "Î∂àÎüâ Í±¥Ïàò", "visible": True},
                        },
                    ],
                )
            )

            # Í∏∞Î≥∏ Ï†úÎ™© ÏÑ§Ï†ï (Ï†ÑÏ≤¥ Î∂ÑÌè¨Í∞Ä Í∏∞Î≥∏)
            default_title = "Í∞ÄÏïïÍ≤ÄÏÇ¨ Î∂ÄÌíàÎ≥Ñ Ï†ÑÏ≤¥ Î∂ÑÌè¨ (TOP10)"

            # Î†àÏù¥ÏïÑÏõÉ ÏÑ§Ï†ï
            fig.update_layout(
                title=dict(text=default_title, x=0.5, xanchor="center"),
                xaxis=dict(
                    visible=False, showgrid=False, zeroline=False
                ),  # ÌååÏù¥Ï∞®Ìä∏Í∞Ä Í∏∞Î≥∏Ïù¥ÎØÄÎ°ú Ï∂ï Ïà®ÍπÄ
                yaxis=dict(visible=False, showgrid=False, zeroline=False),
                height=500,
                margin=dict(l=50, r=50, t=100, b=50),
                template="plotly_white",
                updatemenus=[
                    dict(
                        buttons=dropdown_buttons,
                        direction="down",
                        pad={"r": 10, "t": 10},
                        showactive=True,
                        x=0.1,
                        xanchor="left",
                        y=1.15,
                        yanchor="top",
                    )
                ],
                showlegend=False,
            )

            return fig

        except Exception as e:
            logger.error(f"‚ùå ÎìúÎ°≠Îã§Ïö¥ Î∂ÄÌíà Ï∞®Ìä∏ ÏÉùÏÑ± Ïã§Ìå®: {e}")
            flush_log(logger)
            raise

    def generate_defect_analysis_html(self) -> str:
        """Î∂àÎüâ Î∂ÑÏÑù HTML ÌéòÏù¥ÏßÄ ÏÉùÏÑ± - ÌÉ≠ Í∏∞Î∞ò ÌÜµÌï© ÎåÄÏãúÎ≥¥Îìú"""
        try:
            logger.info("üé® ÌÜµÌï© Î∂àÎüâ Î∂ÑÏÑù HTML ÏÉùÏÑ± ÏãúÏûë...")

            # Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò ÌÜµÍ≥Ñ Í≥ÑÏÇ∞
            monthly_data = self.extract_monthly_data()
            supplier_data = self.extract_supplier_data()

            # Ï¥ù Î∂àÎüâ Í±¥Ïàò (ÏõîÎ≥Ñ Î∂àÎüâ Í±¥Ïàò Ìï©Í≥Ñ)
            total_defects = sum(monthly_data["defect_counts"])

            # Ï¥ù Í≤ÄÏÇ¨ CHÏàò (ÏõîÎ≥Ñ Í≤ÄÏÇ¨ CHÏàò Ìï©Í≥Ñ)
            total_ch_count = sum(monthly_data["ch_counts"])

            # ÌèâÍ∑† Î∂àÎüâÎ•† Í≥ÑÏÇ∞
            avg_defect_rate = (
                (total_defects / total_ch_count * 100) if total_ch_count > 0 else 0
            )

            # Ï£ºÏöî Ïô∏Ï£ºÏÇ¨ Ïàò
            supplier_count = len(supplier_data["suppliers"])

            logger.info(
                f"üìä Ïã§Ï†ú ÌÜµÍ≥Ñ - Ï¥ù Î∂àÎüâ: {total_defects}Í±¥, Ï¥ù CHÏàò: {total_ch_count}, ÌèâÍ∑† Î∂àÎüâÎ•†: {avg_defect_rate:.1f}%, Ïô∏Ï£ºÏÇ¨: {supplier_count}Í∞ú"
            )

            # Í∞ÄÏïïÍ≤ÄÏÇ¨ Ï∞®Ìä∏Îì§ ÏÉùÏÑ± (Í∏∞Ï°¥ Î°úÏßÅ Í∑∏ÎåÄÎ°ú)
            monthly_chart = self.create_monthly_trend_chart()
            action_integrated_chart = self.create_action_type_integrated_chart()
            supplier_integrated_chart = self.create_supplier_integrated_chart()
            part_monthly_chart = self.create_part_monthly_chart()

            # Ï†úÏ°∞ÌíàÏßà Ï∞®Ìä∏Îì§ ÏÉùÏÑ± (Í∞ÄÏïïÍ≤ÄÏÇ¨ÏôÄ ÎèôÏùºÌïú 4Í∞ú Ï∞®Ìä∏)
            quality_monthly_chart = self.create_quality_monthly_trend_chart()
            quality_action_chart = self.create_quality_action_integrated_chart()
            quality_supplier_chart = self.create_quality_supplier_integrated_chart()
            quality_part_chart = self.create_quality_part_monthly_chart()

            # Ï†úÏ°∞ÌíàÏßà Ï∞®Ìä∏Î•º HTMLÎ°ú Î≥ÄÌôò
            quality_monthly_html = quality_monthly_chart.to_html(
                include_plotlyjs=False, div_id="quality-monthly-chart"
            )
            quality_action_html = quality_action_chart.to_html(
                include_plotlyjs=False, div_id="quality-action-chart"
            )
            quality_supplier_html = quality_supplier_chart.to_html(
                include_plotlyjs=False, div_id="quality-supplier-chart"
            )
            quality_part_html = quality_part_chart.to_html(
                include_plotlyjs=False, div_id="quality-part-chart"
            )

            # Ï†úÏ°∞ÌíàÏßà Ïã§Ï†ú ÌÜµÍ≥Ñ Í≥ÑÏÇ∞
            quality_monthly_data = self.extract_quality_monthly_data()
            quality_supplier_data = self.extract_quality_supplier_data()

            quality_total_defects = sum(quality_monthly_data["defect_counts"])
            quality_total_ch = sum(quality_monthly_data["ch_counts"])
            quality_avg_rate = (
                (quality_total_defects / quality_total_ch * 100)
                if quality_total_ch > 0
                else 0
            )
            quality_supplier_count = len(quality_supplier_data["suppliers"])

            logger.info(
                f"üìä Ï†úÏ°∞ÌíàÏßà Ïã§Ï†ú ÌÜµÍ≥Ñ - Ï¥ù Î∂àÎüâ: {quality_total_defects}Í±¥, Ï¥ù CHÏàò: {quality_total_ch}, ÌèâÍ∑† Î∂àÎüâÎ•†: {quality_avg_rate:.1f}%, Ïô∏Ï£ºÏÇ¨: {quality_supplier_count}Í∞ú"
            )

            # Ï∞®Ìä∏Î•º HTMLÎ°ú Î≥ÄÌôò
            monthly_html = monthly_chart.to_html(
                include_plotlyjs="cdn", div_id="monthly-chart"
            )
            action_integrated_html = action_integrated_chart.to_html(
                include_plotlyjs=False, div_id="action-integrated-chart"
            )
            supplier_integrated_html = supplier_integrated_chart.to_html(
                include_plotlyjs=False, div_id="supplier-integrated-chart"
            )
            part_monthly_html = part_monthly_chart.to_html(
                include_plotlyjs=False, div_id="part-monthly-chart"
            )

            # ÌÜµÌï© ÌÜµÍ≥Ñ
            integrated_total_defects = total_defects + quality_total_defects
            integrated_total_ch = total_ch_count + quality_total_ch
            integrated_avg_rate = (
                (integrated_total_defects / integrated_total_ch * 100)
                if integrated_total_ch > 0
                else 0
            )

            # Ï†ÑÏ≤¥ HTML ÌÖúÌîåÎ¶ø (ÌÉ≠ Í∏∞Î∞ò)
            html_template = f"""
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GST ÌÜµÌï© Í≤ÄÏÇ¨ Î∂ÑÏÑù ÎåÄÏãúÎ≥¥Îìú</title>
    <style>
        body {{
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }}
        .header {{
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }}
        .header h1 {{
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
            position: relative;
            cursor: pointer;
        }}
        .header p {{
            margin: 10px 0 0 0;
            font-size: 1.2em;
            opacity: 0.9;
        }}
        
        /* ÌÉ≠ Ïä§ÌÉÄÏùº */
        .tab-container {{
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }}
        .tab-nav {{
            display: flex;
            border-bottom: 1px solid #e0e0e0;
            border-radius: 10px 10px 0 0;
            overflow: hidden;
        }}
        .tab-button {{
            flex: 1;
            padding: 15px 20px;
            background: #f8f9fa;
            border: none;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
        }}
        .tab-button.active {{
            background: white;
            color: #667eea;
            border-bottom-color: #667eea;
        }}
        .tab-button:hover {{
            background: #e9ecef;
        }}
        .tab-button.active:hover {{
            background: white;
        }}
        
        /* ÌÉ≠ ÏΩòÌÖêÏ∏† */
        .tab-content {{
            display: none;
            padding: 20px;
            animation: fadeIn 0.3s ease-in;
        }}
        .tab-content.active {{
            display: block;
        }}
        
        @keyframes fadeIn {{
            from {{ opacity: 0; transform: translateY(10px); }}
            to {{ opacity: 1; transform: translateY(0); }}
        }}
        
        .summary-stats {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }}
        .stat-card {{
            background: linear-gradient(135deg, #fff 0%, #f8f9fa 100%);
            padding: 25px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }}
        .stat-card:hover {{
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }}
        .stat-number {{
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 10px;
        }}
        .stat-label {{
            color: #666;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }}
        
        .chart-container {{
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }}
        
        /* Ìà¥ÌåÅ Ïä§ÌÉÄÏùº */
        .tooltip {{
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 20px;
            border-radius: 12px;
            font-size: 11px;
            line-height: 1.6;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            pointer-events: none;
            min-width: 1000px;
            max-width: 1200px;
            white-space: nowrap;
        }}
        
        .tooltip.show {{
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(10px);
        }}
        
        .tooltip-content {{
            display: flex;
            flex-direction: column;
            gap: 15px;
        }}
        
        .tooltip-title {{
            font-size: 14px;
            font-weight: bold;
            color: #ffd700;
            text-align: center;
            margin-bottom: 10px;
            border-bottom: 1px solid #444;
            padding-bottom: 8px;
        }}
        
        .tooltip-tables-container {{
            display: flex;
            gap: 30px;
            justify-content: space-between;
        }}
        
        .tooltip-section {{
            flex: 1;
        }}
        
        .tooltip-section-title {{
            font-size: 12px;
            font-weight: bold;
            color: #87ceeb;
            margin-bottom: 10px;
            text-align: center;
            padding: 5px;
            background: rgba(135, 206, 235, 0.1);
            border-radius: 5px;
        }}
        
        .tooltip-table {{
            width: 100%;
        }}
        
        .tooltip-table table {{
            width: 100%;
            border-collapse: collapse;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            overflow: hidden;
        }}
        
        .tooltip-table th {{
            background: rgba(135, 206, 235, 0.2);
            color: #87ceeb;
            padding: 8px 6px;
            font-size: 10px;
            font-weight: bold;
            text-align: center;
            border-bottom: 1px solid #555;
        }}
        
        .tooltip-table td {{
            padding: 6px;
            font-size: 10px;
            border-bottom: 1px solid #333;
            vertical-align: top;
        }}
        
        .tooltip-table td:first-child {{
            font-weight: bold;
            color: #ffd700;
            text-align: center;
            width: 80px;
        }}
        
        .tooltip-table td:last-child {{
            color: #ffeaa7;
            font-style: italic;
        }}
        
        .tooltip::before {{
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 8px solid rgba(0, 0, 0, 0.95);
        }}
        
        /* Í∏∞Ï°¥ Ïä§ÌÉÄÏùºÎì§ */
        .chart-wrapper {{
            margin-bottom: 30px;
        }}
        .custom-select {{
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
            margin-bottom: 15px;
            cursor: pointer;
        }}
        .section-title {{
            color: #333;
            font-size: 1.2em;
            margin: 20px 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 2px solid #667eea;
        }}
    </style>
</head>
<body>
    <div class="header">
        <h1 id="dashboard-title">GST ÌÜµÌï© Í≤ÄÏÇ¨ Î∂ÑÏÑù ÎåÄÏãúÎ≥¥Îìú
            <div class="tooltip" id="title-tooltip">
                <div class="tooltip-content">
                    <div class="tooltip-title">üîß Î∂àÎüâ Ï°∞Ïπò Ï†ïÏùò Í∞ÄÏù¥Îìú</div>
                    
                    <div class="tooltip-tables-container">
                        <div class="tooltip-section tooltip-section-left">
                            <div class="tooltip-section-title">üìã Í∞ÄÏïï Î∂àÎüâ Ï°∞Ïπò Ï†ïÏùò</div>
                            <div class="tooltip-table">
                                <table>
                                    <tr>
                                        <th>Ï°∞Ïπò</th>
                                        <th>Ï†ïÏùò</th>
                                        <th>ÏòàÏãú</th>
                                    </tr>
                                    <tr>
                                        <td><strong>‚ë† Ïû¨Ï≤¥Í≤∞</strong></td>
                                        <td>Îã®ÏàúÌïú Ï°∞ÏûÑ Î∂àÎüâ, ÎØ∏ÏôÑÏ≤¥Í≤∞ Îì± Ïû¨Ï≤¥Í≤∞Ïãú LEAKÍ∞Ä Ïû°ÌûàÎäî Í≤ΩÏö∞<br>Í∏∞Ï°¥ ASSYÎÇò Î∂ÄÌíàÏùÑ Ïú†ÏßÄÌïú Ï±Ñ ÌíÄÏóàÎã§ Îã§Ïãú Ï°∞Ïù¥Îäî ÏûëÏóÖ</td>
                                        <td class="example-text">ÌÅ¥Îû®ÌîÑ, ÎÑàÌä∏ Îì± Ï≤¥Í≤∞Ïù¥ Ï†úÎåÄÎ°ú ÎêòÏñ¥ÏûàÏßÄ ÏïäÏùÄÍ≤ΩÏö∞</td>
                                    </tr>
                                    <tr>
                                        <td><strong>‚ë° Ïû¨ÏûëÏóÖ</strong></td>
                                        <td>LEAKÍ∞Ä Ïû¨Ï≤¥Í≤∞ÎßåÏúºÎ°ú Ïû°ÌûàÏßÄ ÏïäÎäî Í≤ΩÏö∞<br>Î∂ÄÌíàÏù¥ÎÇò ASSYÎ•º Î∂ÑÌï¥ ÌõÑ Îã§Ïãú Ï°∞Î¶ΩÌïòÎäî ÏûëÏóÖ</td>
                                        <td class="example-text">Union, Elbow Îì± Ïù¥Ïùå Î∂ÄÏúÑÏóêÏÑú ÎàÑÏÑ§Ïù¥ Í≥ÑÏÜç Î∞úÏÉùÌïòÎäî Í≤ΩÏö∞</td>
                                    </tr>
                                    <tr>
                                        <td><strong>‚ë¢ Ïû¨Ï°∞Î¶Ω</strong></td>
                                        <td>ÌååÌä∏Í∞Ä ÌååÏÜêÎêòÎäî Í≤ΩÏö∞<br>ÌååÏÜêÎêú Î∂ÄÌíàÏùÑ ÏÉàÍ≤ÉÏúºÎ°ú ÍµêÏ≤¥ ÌõÑ Ïû¨Ï°∞Î¶Ω</td>
                                        <td class="example-text">Ï°∞Î¶Ω Í≥ºÏ†ïÏóêÏÑú O-ring, Í∞ÄÏä§Ïºì Îì±Ïù¥ ÏÜêÏÉÅÎêú Í≤ΩÏö∞</td>
                                    </tr>
                                    <tr>
                                        <td><strong>‚ë£ Teflon ÏûëÏóÖ</strong></td>
                                        <td>ÏûêÏ≤¥ SealingÏúºÎ°ú LEAKÍ∞Ä Ïû°ÌûàÏßÄ ÏïäÎäî Í≤ΩÏö∞<br>Teflon ÌÖåÏù¥ÌîÑÎÇò Ïã§Îü∞Ìä∏ Ï∂îÍ∞Ä Ï†ÅÏö©</td>
                                        <td class="example-text">ÎÇòÏÇ¨ÏÇ∞ Î∂ÄÏúÑÏóêÏÑú ÎØ∏ÏÑ∏Ìïú ÎàÑÏÑ§Ïù¥ ÏßÄÏÜçÎêòÎäî Í≤ΩÏö∞</td>
                                    </tr>
                                    <tr>
                                        <td><strong>‚ë§ ÌååÌä∏ÍµêÏ≤¥</strong></td>
                                        <td>ÌíàÏßà Î∂àÎüâÏúºÎ°ú ÏßÄÏÜçÏ†Å Î∞úÏÉù<br>Ìï¥Îãπ Î∂ÄÌíà ÏûêÏ≤¥Î•º ÏÉàÍ≤ÉÏúºÎ°ú ÏôÑÏ†Ñ ÍµêÏ≤¥</td>
                                        <td class="example-text">Î∂ÄÌíà ÏûêÏ≤¥Ïùò ÏπòÏàò Î∂àÎüâÏù¥ÎÇò Ïû¨Ïßà Î¨∏Ï†úÍ∞Ä ÏûàÎäî Í≤ΩÏö∞</td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        
                        <div class="tooltip-section tooltip-section-right">
                            <div class="tooltip-section-title">üè≠ Ï†úÏ°∞ÌíàÏßà Î∂àÎüâ Ï°∞Ïπò Ï†ïÏùò</div>
                            <div class="tooltip-table">
                                <table>
                                    <tr>
                                        <th>Ï°∞Ïπò</th>
                                        <th>Ï†ïÏùò</th>
                                        <th>ÏòàÏãú</th>
                                    </tr>
                                    <tr>
                                        <td><strong>‚ë† Ïû¨Ï≤¥Í≤∞</strong></td>
                                        <td>Îã®ÏàúÌïú Ï≤¥Í≤∞ Î∂àÎüâ<br>Î≥ºÌä∏, ÎÇòÏÇ¨ Îì±Ïùò Ï°∞ÏûÑÏù¥ Î∂ÄÏ°±ÌïòÍ±∞ÎÇò Í≥ºÎã§Ìïú Í≤ΩÏö∞</td>
                                        <td class="example-text">Ïª§Î≤Ñ, Î∏åÎùºÏºì Îì±Ïùò Ï≤¥Í≤∞ ÌÜ†ÌÅ¨ Î∂ÄÏ°±</td>
                                    </tr>
                                    <tr>
                                        <td><strong>‚ë° Ïû¨ÏûëÏóÖ</strong></td>
                                        <td>ÏûòÎ™ªÎêú ÏûëÏóÖÏúºÎ°ú Ïù∏Ìïú Í∏∞Îä• Ïù¥ÏÉÅ<br>ÏûëÏóÖ ÏàúÏÑúÎÇò Î∞©Î≤ïÏùÑ Îã§Ïãú ÏàòÌñâ</td>
                                        <td class="example-text">Î∞∞ÏÑ† Ïó∞Í≤∞ Ïò§Î•ò, Î∂ÄÌíà Ïû•Ï∞© ÏúÑÏπò Ïò§Î•ò</td>
                                    </tr>
                                    <tr>
                                        <td><strong>‚ë¢ ÏãùÎ≥Ñ Ï°∞Ïπò</strong></td>
                                        <td>Ïô∏Í¥ÄÏÉÅ Íµ¨Î∂ÑÎêòÎäî Î∂àÎüâ<br>ÎùºÎ≤®ÎßÅ, ÎßàÌÇπ Îì±Ïùò ÏãùÎ≥Ñ Í¥ÄÎ†® Ï°∞Ïπò</td>
                                        <td class="example-text">Ï†úÌíà ÎùºÎ≤® Î∂ÄÏ∞© ÎàÑÎùΩ, Î™®Îç∏Î™Ö ÌëúÏãú Ïò§Î•ò</td>
                                    </tr>
                                    <tr>
                                        <td><strong>‚ë£ Teflon ÏûëÏóÖ</strong></td>
                                        <td>Î∞ÄÎ¥â Í¥ÄÎ†® Î≥¥ÏôÑ ÏûëÏóÖ<br>Í∞ÄÏïï Í≥µÏ†ïÍ≥º ÎèôÏùºÌïú Ïã§ÎßÅ Î≥¥Í∞ï</td>
                                        <td class="example-text">Ïó∞Í≤∞Î∂Ä ÎàÑÏÑ§ Î∞©ÏßÄÎ•º ÏúÑÌïú Ï∂îÍ∞Ä Ïã§ÎßÅ</td>
                                    </tr>
                                    <tr>
                                        <td><strong>‚ë§ ÌååÌä∏ÍµêÏ≤¥</strong></td>
                                        <td>ÌååÌä∏ ÏûêÏ≤¥ Î¨∏Ï†ú<br>Î∂àÎüâ Î∂ÄÌíàÏùÑ Ï†ïÏÉÅ Î∂ÄÌíàÏúºÎ°ú ÍµêÏ≤¥</td>
                                        <td class="example-text">ÏÑºÏÑú, Ïª§ÎÑ•ÌÑ∞ Îì± Ï†ÑÏûê Î∂ÄÌíàÏùò Í∏∞Îä• Î∂àÎüâ</td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </h1>
        <p>2025ÎÖÑ ÌÜµÌï© Í≤ÄÏÇ¨(Í∞ÄÏïïÍ≤ÄÏÇ¨ + Ï†úÏ°∞ÌíàÏßà) Î∂àÎüâ ÌòÑÌô© Î∞è Î∂ÑÏÑù</p>
    </div>
    
    <div class="tab-container">
        <div class="tab-nav">
            <button class="tab-button active" onclick="showTab('pressure')">Í∞ÄÏïïÍ≤ÄÏÇ¨</button>
            <button class="tab-button" onclick="showTab('quality')">Ï†úÏ°∞ÌíàÏßà</button>
            <button class="tab-button" onclick="showTab('integrated')">ÌÜµÌï©ÎπÑÍµê</button>
        </div>
        
        <div id="pressure-tab" class="tab-content active">
            
            <!-- Í∞ÄÏïïÍ≤ÄÏÇ¨ Í∞úÎ≥Ñ ÌÜµÍ≥Ñ -->
            <div class="summary-stats" style="margin-bottom: 30px;">
                <div class="stat-card">
                    <div class="stat-number">{total_defects}</div>
                    <div class="stat-label">Ï¥ù Î∂àÎüâ Í±¥Ïàò</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">{total_ch_count}</div>
                    <div class="stat-label">Ï¥ù Í≤ÄÏÇ¨ CHÏàò</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">{avg_defect_rate:.1f}%</div>
                    <div class="stat-label">ÌèâÍ∑† Î∂àÎüâÎ•†</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">{supplier_count}</div>
                    <div class="stat-label">Ï£ºÏöî Ïô∏Ï£ºÏÇ¨</div>
                </div>
            </div>
            
            <div class="chart-container">
                {monthly_html}
            </div>
            
            <div class="chart-container">
                {action_integrated_html}
            </div>
            
            <div class="chart-container">
                {supplier_integrated_html}
            </div>
            
            <div class="chart-container">
                {part_monthly_html}
            </div>
        </div>
        
        <div id="quality-tab" class="tab-content">
            
            <!-- Ï†úÏ°∞ÌíàÏßà Í∞úÎ≥Ñ ÌÜµÍ≥Ñ -->
            <div class="summary-stats" style="margin-bottom: 30px;">
                <div class="stat-card">
                    <div class="stat-number">{quality_total_defects}</div>
                    <div class="stat-label">Ï¥ù Î∂àÎüâ Í±¥Ïàò</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">{quality_total_ch}</div>
                    <div class="stat-label">Ï¥ù Í≤ÄÏÇ¨ CHÏàò</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">{quality_avg_rate:.1f}%</div>
                    <div class="stat-label">ÌèâÍ∑† Î∂àÎüâÎ•†</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">{quality_supplier_count}</div>
                    <div class="stat-label">Ï£ºÏöî Ïô∏Ï£ºÏÇ¨</div>
                </div>
            </div>
            
            <div class="chart-container">
                {quality_monthly_html}
            </div>
            
            <div class="chart-container">
                {quality_action_html}
            </div>
            
            <div class="chart-container">
                {quality_supplier_html}
            </div>
            
            <div class="chart-container">
                {quality_part_html}
            </div>
        </div>
        
        <div id="integrated-tab" class="tab-content">
            <h2>üîÑ ÌÜµÌï© ÎπÑÍµê Î∂ÑÏÑù</h2>
            <div class="chart-container">
                <p style="text-align: center; color: #666; font-size: 1.1em; padding: 50px;">
                    üìä Í∞ÄÏïïÍ≤ÄÏÇ¨ÏôÄ Ï†úÏ°∞ÌíàÏßà Í≥µÏ†ïÏùò ÌÜµÌï© ÎπÑÍµê Î∂ÑÏÑùÏûÖÎãàÎã§.<br>
                    <small>ÌÜµÌï© Î∂ÑÏÑù Ï∞®Ìä∏ Ï§ÄÎπÑ Ï§ë...</small>
                </p>
            </div>
        </div>
    </div>
    
    <script>
        // ÌÉ≠ Ï†ÑÌôò Í∏∞Îä•
        function showTab(tabName) {{
            // Î™®Îì† ÌÉ≠ Î≤ÑÌäºÍ≥º ÏΩòÌÖêÏ∏† ÎπÑÌôúÏÑ±Ìôî
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // ÏÑ†ÌÉùÎêú ÌÉ≠ ÌôúÏÑ±Ìôî
            event.target.classList.add('active');
            document.getElementById(tabName + '-tab').classList.add('active');
            
            // ÌÉ≠ Ï†ÑÌôò ÌõÑ Ï∞®Ìä∏ Î¶¨ÏÇ¨Ïù¥Ï¶à
            resizeCharts();
        }}
        
        // Plotly Ï∞®Ìä∏ Ï¥àÍ∏∞Ìôî Ìï®Ïàò
        function initializeCharts() {{
            // Î™®Îì† Plotly Ï∞®Ìä∏ Ïª®ÌÖåÏù¥ÎÑàÎ•º Ï∞æÏïÑÏÑú Í∞ïÏ†ú Î†åÎçîÎßÅ
            const chartDivs = document.querySelectorAll('div[id*="chart"]');
            chartDivs.forEach(function(div) {{
                if (window.Plotly && div.data) {{
                    Plotly.redraw(div);
                }}
            }});
        }}
        
        // Ï∞®Ìä∏ Í∞ïÏ†ú Î¶¨ÏÇ¨Ïù¥Ï¶à Ìï®Ïàò
        function resizeCharts() {{
            setTimeout(function() {{
                const chartDivs = document.querySelectorAll('div[id*="chart"]');
                chartDivs.forEach(function(div) {{
                    if (window.Plotly && div.data) {{
                        Plotly.Plots.resize(div);
                    }}
                }});
            }}, 100);
        }}
        
        // Ìà¥ÌåÅ Í∏∞Îä•
        document.addEventListener('DOMContentLoaded', function() {{
            const title = document.getElementById('dashboard-title');
            const tooltip = document.getElementById('title-tooltip');
            let showTimeout, hideTimeout;
            
            title.addEventListener('mouseenter', function() {{
                clearTimeout(hideTimeout);
                showTimeout = setTimeout(() => {{
                    tooltip.classList.add('show');
                }}, 300);
            }});
            
            title.addEventListener('mouseleave', function() {{
                clearTimeout(showTimeout);
                hideTimeout = setTimeout(() => {{
                    tooltip.classList.remove('show');
                }}, 300);
            }});
            
            // ÌéòÏù¥ÏßÄ Î°úÎìú ÏôÑÎ£å ÌõÑ Ï∞®Ìä∏ Ï¥àÍ∏∞Ìôî
            setTimeout(function() {{
                initializeCharts();
                resizeCharts();
            }}, 500);
            
            // ÏúàÎèÑÏö∞ Î¶¨ÏÇ¨Ïù¥Ï¶à Ïãú Ï∞®Ìä∏ Î¶¨ÏÇ¨Ïù¥Ï¶à
            window.addEventListener('resize', resizeCharts);
        }});
    </script>
</body>
</html>
"""

            logger.info("‚úÖ ÌÜµÌï© Î∂àÎüâ Î∂ÑÏÑù HTML ÏÉùÏÑ± ÏôÑÎ£å")
            flush_log(logger)

            return html_template

        except Exception as e:
            logger.error(f"‚ùå ÌÜµÌï© Î∂àÎüâ Î∂ÑÏÑù HTML ÏÉùÏÑ± Ïã§Ìå®: {e}")
            flush_log(logger)
            raise

    def save_html_report(self, filename: str = "defect_analysis_dashboard.html") -> str:
        """HTML Î¶¨Ìè¨Ìä∏ ÌååÏùº Ï†ÄÏû•"""
        try:
            html_content = self.generate_defect_analysis_html()

            with open(filename, "w", encoding="utf-8") as f:
                f.write(html_content)

            logger.info(f"‚úÖ HTML Î¶¨Ìè¨Ìä∏ Ï†ÄÏû• ÏôÑÎ£å: {filename}")
            flush_log(logger)

            return filename

        except Exception as e:
            logger.error(f"‚ùå HTML Î¶¨Ìè¨Ìä∏ Ï†ÄÏû• Ïã§Ìå®: {e}")
            flush_log(logger)
            raise

    def save_and_upload_internal_report(self) -> bool:
        """internal.htmlÎ°ú Ï†ÄÏû•ÌïòÍ≥† GitHubÏóê ÏóÖÎ°úÎìú"""
        try:
            from output.github_uploader import GitHubUploader
            from config import github_config

            # 1. HTML ÏÉùÏÑ±
            logger.info("üîÑ internal.html ÏÉùÏÑ± Ï§ë...")
            html_content = self.generate_defect_analysis_html()

            # 2. Î°úÏª¨ Ï†ÄÏû•
            local_filename = "internal.html"
            with open(local_filename, "w", encoding="utf-8") as f:
                f.write(html_content)
            logger.info(f"‚úÖ Î°úÏª¨ Ï†ÄÏû• ÏôÑÎ£å: {local_filename}")

            # 3. GitHub ÏóÖÎ°úÎìú
            logger.info("üöÄ GitHub ÏóÖÎ°úÎìú Ï§ë...")
            uploader = GitHubUploader()

            # config.pyÏùò GitHubConfig ÏÇ¨Ïö©
            upload_success = uploader.upload_file(
                content=html_content,
                username=github_config.username_2,
                repo=github_config.repo_2,
                branch=github_config.branch_2,
                token=github_config.token_2,
                filename="public/internal.html",
                message="Daily internal dashboard update",
            )

            if upload_success:
                logger.info("‚úÖ internal.html GitHub ÏóÖÎ°úÎìú ÏÑ±Í≥µ!")
                logger.info(
                    f"üåê Ï†ëÏÜç URL: https://{github_config.username_2}.github.io/{github_config.repo_2}/public/internal.html"
                )
                return True
            else:
                logger.error("‚ùå GitHub ÏóÖÎ°úÎìú Ïã§Ìå®")
                return False
            return True

        except Exception as e:
            logger.error(f"‚ùå internal.html ÏóÖÎ°úÎìú Ïã§Ìå®: {e}")
            return False

    def load_quality_analysis_data(self) -> pd.DataFrame:
        """Ï†úÏ°∞ÌíàÏßà Î∂àÎüâÎ∂ÑÏÑù ÏõåÌÅ¨ÏãúÌä∏ Îç∞Ïù¥ÌÑ∞ Î°úÎìú"""
        try:
            if self.use_mock_data:
                logger.info("üìä Mock Ï†úÏ°∞ÌíàÏßà Î∂àÎüâÎ∂ÑÏÑù Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©...")

                # Mock Ï†úÏ°∞ÌíàÏßà Î∂àÎüâÎ∂ÑÏÑù Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
                analysis_data = [
                    ["", "", "Íµ¨Î∂Ñ", "1Ïõî", "2Ïõî", "3Ïõî", "4Ïõî", "5Ïõî", "6Ïõî", "7Ïõî"],
                    ["", "", "Í≤ÄÏÇ¨ ChÏàò", 95, 105, 88, 98, 112, 90, 102],
                    ["", "", "Î∂àÎüâ Í±¥Ïàò", 15, 18, 12, 20, 22, 14, 25],
                    [
                        "",
                        "",
                        "CHÎãπ Î∂àÎüâÎ•†",
                        0.158,
                        0.171,
                        0.136,
                        0.204,
                        0.196,
                        0.156,
                        0.245,
                    ],
                ]
                df = pd.DataFrame(analysis_data)
                logger.info(f"‚úÖ Mock Ï†úÏ°∞ÌíàÏßà Î∂àÎüâÎ∂ÑÏÑù Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏôÑÎ£å: {df.shape}")
                flush_log(logger)
                return df

            logger.info("üìä Ï†úÏ°∞ÌíàÏßà Î∂àÎüâÎ∂ÑÏÑù ÏõåÌÅ¨ÏãúÌä∏ Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏãúÏûë...")

            # TeamsÏóêÏÑú ÌååÏùº Îã§Ïö¥Î°úÎìú
            files = self.teams_loader._get_teams_files()
            excel_file = self.teams_loader._find_excel_file(files)
            file_content = self.teams_loader._download_excel_file(excel_file)

            # Ï†úÏ°∞ÌíàÏßà Î∂àÎüâÎ∂ÑÏÑù ÏõåÌÅ¨ÏãúÌä∏ Î°úÎìú
            excel_buffer = io.BytesIO(file_content)
            df = pd.read_excel(excel_buffer, sheet_name="Ï†úÏ°∞ÌíàÏßà Î∂àÎüâÎ∂ÑÏÑù")

            logger.info(f"‚úÖ Ï†úÏ°∞ÌíàÏßà Î∂àÎüâÎ∂ÑÏÑù Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏôÑÎ£å: {df.shape}")
            flush_log(logger)

            return df

        except Exception as e:
            logger.error(f"‚ùå Ï†úÏ°∞ÌíàÏßà Î∂àÎüâÎ∂ÑÏÑù Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®: {e}")
            flush_log(logger)
            raise

    def load_quality_defect_data(self) -> pd.DataFrame:
        """Ï†úÏ°∞ÌíàÏßà Î∂àÎüâÎÇ¥Ïó≠ ÏõåÌÅ¨ÏãúÌä∏ Îç∞Ïù¥ÌÑ∞ Î°úÎìú"""
        try:
            if self.use_mock_data:
                logger.info("üìä Mock Ï†úÏ°∞ÌíàÏßà Î∂àÎüâÎÇ¥Ïó≠ Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©...")

                # Mock Ï†úÏ°∞ÌíàÏßà Î∂àÎüâÎÇ¥Ïó≠ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ± (Í∞ÄÏïïÍ≤ÄÏÇ¨ÏôÄ ÎèôÏùºÌïú Íµ¨Ï°∞)
                mock_data = {
                    "Î™®Îç∏": ["Model-X", "Model-Y", "Model-Z"] * 15,
                    "Î∂ÄÌíàÎ™Ö": ["SPEED CONTROLLER", "FEMALE CONNECTOR", "MALE CONNECTOR"]
                    * 15,
                    "Ïô∏Ï£ºÏÇ¨": ["Ï†úÏ°∞ÏóÖÏ≤¥A", "Ï†úÏ°∞ÏóÖÏ≤¥B", "Ï†úÏ°∞ÏóÖÏ≤¥C"] * 15,
                    "Ï°∞Ïπò": ["Ïû¨Ï≤¥Í≤∞", "Ïû¨ÏûëÏóÖ", "Ïû¨Ï°∞Î¶Ω", "Teflon ÏûëÏóÖ", "ÌååÌä∏ÍµêÏ≤¥"]
                    * 9,
                    "ÎåÄÎ∂ÑÎ•ò": ["Ï†ÑÏû•ÏûëÏóÖÎ∂àÎüâ", "Í∏∞Íµ¨ÏûëÏóÖÎ∂àÎüâ", "Í≤ÄÏÇ¨ÌíàÏßàÎ∂àÎüâ"] * 15,
                    "Ï§ëÎ∂ÑÎ•ò": ["Î∞∞ÏÑ†Î∂àÎüâ", "Ï°∞Î¶ΩÎ∂àÎüâ", "ÏãùÎ≥ÑÎ∂àÎüâ"] * 15,
                }
                df = pd.DataFrame(mock_data)
                logger.info(f"‚úÖ Mock Ï†úÏ°∞ÌíàÏßà Î∂àÎüâÎÇ¥Ïó≠ Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏôÑÎ£å: {df.shape}")
                flush_log(logger)
                return df

            logger.info("üìä Ï†úÏ°∞ÌíàÏßà Î∂àÎüâÎÇ¥Ïó≠ Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏãúÏûë...")

            # TeamsÏóêÏÑú ÌååÏùº Îã§Ïö¥Î°úÎìú
            files = self.teams_loader._get_teams_files()
            excel_file = self.teams_loader._find_excel_file(files)
            file_content = self.teams_loader._download_excel_file(excel_file)

            # Ï†úÏ°∞ÌíàÏßà Î∂àÎüâÎÇ¥Ïó≠ ÏõåÌÅ¨ÏãúÌä∏ Î°úÎìú
            excel_buffer = io.BytesIO(file_content)
            df = pd.read_excel(excel_buffer, sheet_name="Ï†úÏ°∞ÌíàÏßà Î∂àÎüâÎÇ¥Ïó≠")

            # Ïª¨ÎüºÎ™Ö ÌôïÏù∏ Î∞è OÏó¥(Î∂àÎüâÏúÑÏπò), PÏó¥(ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©) Ïª¨ÎüºÎ™Ö ÏÑ§Ï†ï
            if df.shape[1] >= 16:  # PÏó¥ÍπåÏßÄ ÏûàÎäîÏßÄ ÌôïÏù∏ (PÎäî 16Î≤àÏß∏ Ïª¨Îüº)
                # OÏó¥ (15Î≤àÏß∏, Ïù∏Îç±Ïä§ 14) - Î∂àÎüâÏúÑÏπò
                if df.shape[1] > 14:
                    df.columns.values[14] = "Î∂àÎüâÏúÑÏπò"
                # PÏó¥ (16Î≤àÏß∏, Ïù∏Îç±Ïä§ 15) - ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©
                if df.shape[1] > 15:
                    df.columns.values[15] = "ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©"

            logger.info(f"‚úÖ Ï†úÏ°∞ÌíàÏßà Î∂àÎüâÎÇ¥Ïó≠ Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏôÑÎ£å: {df.shape}")
            logger.info(f"üìä Ïª¨ÎüºÎ™ÖÎì§: {list(df.columns)}")
            flush_log(logger)

            return df

        except Exception as e:
            logger.error(f"‚ùå Ï†úÏ°∞ÌíàÏßà Î∂àÎüâÎÇ¥Ïó≠ Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®: {e}")
            flush_log(logger)
            raise

    def extract_quality_monthly_data(self) -> Dict:
        """Ï†úÏ°∞ÌíàÏßà ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú"""
        try:
            logger.info("üìä Ï†úÏ°∞ÌíàÏßà ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú ÏãúÏûë...")

            if (
                not hasattr(self, "quality_analysis_data")
                or self.quality_analysis_data is None
            ):
                self.quality_analysis_data = self.load_quality_analysis_data()

            months = []
            ch_counts = []
            defect_counts = []
            defect_rates = []

            # Ìó§Îçî Ìñâ Ï∞æÍ∏∞ (Í∞ÄÏïïÍ≤ÄÏÇ¨ÏôÄ ÎèôÏùºÌïú Íµ¨Ï°∞)
            header_row = None
            for idx, row in self.quality_analysis_data.iterrows():
                if pd.notna(row.iloc[1]) and "Íµ¨Î∂Ñ" in str(row.iloc[1]):
                    header_row = idx
                    break

            if header_row is not None:
                # ÏõîÎ≥Ñ Ïª¨Îüº Ï∞æÍ∏∞ (Í∞ÄÏïïÍ≤ÄÏÇ¨ÏôÄ ÎèôÏùºÌïòÍ≤å 2Î≤àÏß∏ Ïª¨ÎüºÎ∂ÄÌÑ∞)
                month_indices = []
                for col_idx in range(2, len(self.quality_analysis_data.columns)):
                    cell_value = self.quality_analysis_data.iloc[header_row, col_idx]
                    if pd.notna(cell_value) and "Ïõî" in str(cell_value):
                        months.append(str(cell_value))
                        month_indices.append(col_idx)

                # Í∞Å ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú
                for month_idx in month_indices:
                    # Í≤ÄÏÇ¨ CHÏàò Ï∞æÍ∏∞ (ÎèôÏùºÌïú ÏúÑÏπò)
                    ch_count = 0
                    for idx, row in self.quality_analysis_data.iterrows():
                        if pd.notna(row.iloc[1]) and "Í≤ÄÏÇ¨ ChÏàò" in str(row.iloc[1]):
                            ch_count = (
                                row.iloc[month_idx]
                                if pd.notna(row.iloc[month_idx])
                                else 0
                            )
                            break
                    ch_counts.append(int(ch_count) if ch_count != 0 else 0)

                    # Î∂àÎüâ Í±¥Ïàò Ï∞æÍ∏∞ (Ï†ïÌôïÌïú ÌÇ§ÏõåÎìú Îß§Ïπ≠)
                    defect_count = 0
                    for idx, row in self.quality_analysis_data.iterrows():
                        cell_value = str(row.iloc[1]) if pd.notna(row.iloc[1]) else ""
                        if cell_value == "Î∂àÎüâ Í±¥Ïàò":  # Ï†ïÌôïÌïú Î¨∏ÏûêÏó¥ Îß§Ïπ≠
                            defect_count = (
                                row.iloc[month_idx]
                                if pd.notna(row.iloc[month_idx])
                                else 0
                            )
                            break
                    defect_counts.append(int(defect_count) if defect_count != 0 else 0)

                    # CHÎãπ Î∂àÎüâÎ•† Ï∞æÍ∏∞ (Ï†ïÌôïÌïú ÌÇ§ÏõåÎìú Îß§Ïπ≠)
                    defect_rate = 0
                    for idx, row in self.quality_analysis_data.iterrows():
                        cell_value = str(row.iloc[1]) if pd.notna(row.iloc[1]) else ""
                        if "CHÎãπ Î∂àÎüâÎ•†" in cell_value:  # CHÎãπ Î∂àÎüâÎ•†Ïù¥ Ìè¨Ìï®Îêú ÏÖÄ
                            defect_rate = (
                                row.iloc[month_idx]
                                if pd.notna(row.iloc[month_idx])
                                else 0
                            )
                            break
                    defect_rates.append(
                        float(defect_rate) * 100 if defect_rate != 0 else 0
                    )

            logger.info(f"üìä Ï†úÏ°∞ÌíàÏßà ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú ÏôÑÎ£å: {len(months)}Í∞úÏõî")

            return {
                "months": months,
                "ch_counts": ch_counts,
                "defect_counts": defect_counts,
                "defect_rates": defect_rates,
            }

        except Exception as e:
            logger.error(f"‚ùå Ï†úÏ°∞ÌíàÏßà ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú Ïã§Ìå®: {e}")
            flush_log(logger)
            raise

    def extract_quality_supplier_data(self) -> Dict:
        """Ï†úÏ°∞ÌíàÏßà Ïô∏Ï£ºÏÇ¨Î≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú (Î∂àÎüâÎ∂ÑÏÑù ÏãúÌä∏ÏóêÏÑú ÎèôÏ†Å Ï∂îÏ∂ú)"""
        try:
            logger.info("üìä Ï†úÏ°∞ÌíàÏßà Ïô∏Ï£ºÏÇ¨Î≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú ÏãúÏûë...")

            if (
                not hasattr(self, "quality_analysis_data")
                or self.quality_analysis_data is None
            ):
                self.quality_analysis_data = self.load_quality_analysis_data()

            suppliers = []
            supplier_counts = []
            supplier_rates = []

            # "Ïô∏Ï£ºÏÇ¨Î≥Ñ Î∂àÎüâÎ•†" ÏÑπÏÖò Ï∞æÍ∏∞
            supplier_section_start = None
            for idx, row in self.quality_analysis_data.iterrows():
                if pd.notna(row.iloc[1]) and "Ïô∏Ï£ºÏÇ¨Î≥Ñ Î∂àÎüâÎ•†" in str(row.iloc[1]):
                    supplier_section_start = idx
                    break

            if supplier_section_start is not None:
                # Ïô∏Ï£ºÏÇ¨Î≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú (Îã§Ïùå ÌñâÎ∂ÄÌÑ∞ ÏãúÏûë)
                idx = supplier_section_start + 1
                while idx < len(self.quality_analysis_data):
                    row = self.quality_analysis_data.iloc[idx]

                    # Îëê Î≤àÏß∏ Ïª¨ÎüºÏù¥ ÎπÑÏñ¥ÏûàÏúºÎ©¥ Ï¢ÖÎ£å
                    if pd.isna(row.iloc[1]):
                        break

                    supplier_name = str(row.iloc[1]).strip()

                    # Ïô∏Ï£ºÏÇ¨ Ïù¥Î¶ÑÏù¥ Ïú†Ìö®ÌïúÏßÄ ÌôïÏù∏ (BAT, FNI, TMS(Í∏∞Íµ¨), C&A, P&S, TMS(Ï†ÑÏû•) Îì±)
                    if supplier_name and supplier_name not in ["NaN", ""]:
                        # ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ìï©Í≥Ñ Í≥ÑÏÇ∞
                        total_count = 0
                        for col_idx in range(
                            2, min(len(self.quality_analysis_data.columns), 9)
                        ):  # 1Ïõî~7Ïõî Îç∞Ïù¥ÌÑ∞
                            cell_value = row.iloc[col_idx]
                            if (
                                pd.notna(cell_value)
                                and str(cell_value).replace(".", "").isdigit()
                            ):
                                total_count += int(float(cell_value))

                        # Îã§Ïùå ÌñâÏóêÏÑú ÎπÑÏú® Ï†ïÎ≥¥ Ï∂îÏ∂ú (Ï†úÏ°∞ÌíàÏßà Ï†ÑÏö© - ÎàÑÍ≥Ñ Ïª¨Îüº ÏÇ¨Ïö©)
                        rate = 0
                        if idx + 1 < len(self.quality_analysis_data):
                            rate_row = self.quality_analysis_data.iloc[idx + 1]
                            # ÎàÑÍ≥Ñ Ïª¨ÎüºÏóêÏÑú ÎπÑÏú® Ï∂îÏ∂ú (Îß® Ïò§Î•∏Ï™Ω Ïª¨Îüº)
                            for col_idx in range(
                                len(self.quality_analysis_data.columns) - 1, 1, -1
                            ):
                                cell_value = rate_row.iloc[col_idx]
                                if pd.notna(cell_value):
                                    # Î∞±Î∂ÑÏú® ÌòïÌÉú(25.0%) ÎòêÎäî ÏÜåÏàò ÌòïÌÉú(0.25) Ï≤òÎ¶¨
                                    if isinstance(cell_value, str) and "%" in str(
                                        cell_value
                                    ):
                                        rate = float(str(cell_value).replace("%", ""))
                                    elif isinstance(cell_value, (int, float)):
                                        # 1Î≥¥Îã§ ÏûëÏúºÎ©¥ ÏÜåÏàòÌòïÌÉúÎ°ú ÌåêÎã®ÌïòÏó¨ Î∞±Î∂ÑÏú®Î°ú Î≥ÄÌôò
                                        rate = (
                                            float(cell_value) * 100
                                            if float(cell_value) <= 1
                                            else float(cell_value)
                                        )
                                    break

                        if total_count > 0:
                            suppliers.append(supplier_name)
                            supplier_counts.append(total_count)
                            supplier_rates.append(round(rate, 1))

                        # Îã§Ïùå Ïô∏Ï£ºÏÇ¨Î°ú Ïù¥Îèô (ÎπÑÏú® Ìñâ Í±¥ÎÑàÎõ∞Í∏∞)
                        idx += 2
                    else:
                        idx += 1

            # Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏúºÎ©¥ Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©
            if not suppliers:
                logger.warning("‚ö†Ô∏è Ï†úÏ°∞ÌíàÏßà ÎèôÏ†Å Ïô∏Ï£ºÏÇ¨ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú Ïã§Ìå®, Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©")
                suppliers = ["TMS(Í∏∞Íµ¨)", "C&A", "P&S"]
                supplier_counts = [5, 1, 1]
                supplier_rates = [1.0, 0.17, 0.17]

            logger.info(
                f"üìä Ï†úÏ°∞ÌíàÏßà Ïô∏Ï£ºÏÇ¨Î≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú ÏôÑÎ£å: {len(suppliers)}Í∞ú ÏóÖÏ≤¥"
            )

            return {
                "suppliers": suppliers,
                "supplier_counts": supplier_counts,
                "supplier_rates": supplier_rates,
            }

        except Exception as e:
            logger.error(f"‚ùå Ï†úÏ°∞ÌíàÏßà Ïô∏Ï£ºÏÇ¨Î≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú Ïã§Ìå®: {e}")
            flush_log(logger)
            # Ïã§Ìå® Ïãú Í∏∞Î≥∏Í∞í Î∞òÌôò
            return {
                "suppliers": ["TMS(Í∏∞Íµ¨)", "C&A", "P&S"],
                "supplier_counts": [5, 1, 1],
                "supplier_rates": [1.0, 0.17, 0.17],
            }

    def extract_quality_supplier_monthly_data(self) -> Dict:
        """Ï†úÏ°∞ÌíàÏßà Ïô∏Ï£ºÏÇ¨Î≥Ñ ÏõîÎ≥Ñ Î∂àÎüâÎ•† Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú"""
        try:
            logger.info("üìä Ï†úÏ°∞ÌíàÏßà Ïô∏Ï£ºÏÇ¨Î≥Ñ ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú ÏãúÏûë...")

            if (
                not hasattr(self, "quality_analysis_data")
                or self.quality_analysis_data is None
            ):
                self.quality_analysis_data = self.load_quality_analysis_data()

            # ÏõîÎ≥Ñ Ïª¨Îüº Ï∞æÍ∏∞
            months = []
            header_row = None
            for idx, row in self.quality_analysis_data.iterrows():
                if pd.notna(row.iloc[1]) and "Íµ¨Î∂Ñ" in str(row.iloc[1]):
                    header_row = idx
                    break

            month_indices = []
            if header_row is not None:
                for col_idx in range(2, len(self.quality_analysis_data.columns)):
                    cell_value = self.quality_analysis_data.iloc[header_row, col_idx]
                    if pd.notna(cell_value) and "Ïõî" in str(cell_value):
                        months.append(str(cell_value))
                        month_indices.append(col_idx)

            # Ïô∏Ï£ºÏÇ¨Î≥Ñ Î∂àÎüâÎ•† ÏÑπÏÖò Ï∞æÍ∏∞
            supplier_section_start = None
            for idx, row in self.quality_analysis_data.iterrows():
                if pd.notna(row.iloc[1]) and "Ïô∏Ï£ºÏÇ¨Î≥Ñ Î∂àÎüâÎ•†" in str(row.iloc[1]):
                    supplier_section_start = idx
                    break

            suppliers_monthly = {}

            if supplier_section_start is not None:
                idx = supplier_section_start + 1
                while idx < len(self.quality_analysis_data):
                    row = self.quality_analysis_data.iloc[idx]

                    # Îëê Î≤àÏß∏ Ïª¨ÎüºÏù¥ ÎπÑÏñ¥ÏûàÏúºÎ©¥ Ï¢ÖÎ£å
                    if pd.isna(row.iloc[1]):
                        break

                    supplier_name = str(row.iloc[1]).strip()

                    # Ïô∏Ï£ºÏÇ¨ Ïù¥Î¶ÑÏù¥ Ïú†Ìö®ÌïúÏßÄ ÌôïÏù∏
                    if supplier_name and supplier_name not in ["NaN", ""]:
                        # Îã§Ïùå ÌñâÏóêÏÑú ÏõîÎ≥Ñ ÎπÑÏú® Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú
                        if idx + 1 < len(self.quality_analysis_data):
                            rate_row = self.quality_analysis_data.iloc[idx + 1]
                            monthly_rates = []

                            for month_idx in month_indices:
                                cell_value = rate_row.iloc[month_idx]
                                if pd.notna(cell_value):
                                    # Î∞±Î∂ÑÏú® ÌòïÌÉú(25.0%) ÎòêÎäî ÏÜåÏàò ÌòïÌÉú(0.25) Ï≤òÎ¶¨
                                    if isinstance(cell_value, str) and "%" in str(
                                        cell_value
                                    ):
                                        monthly_rates.append(
                                            float(str(cell_value).replace("%", ""))
                                        )
                                    elif isinstance(cell_value, (int, float)):
                                        # 1Î≥¥Îã§ ÏûëÏúºÎ©¥ ÏÜåÏàòÌòïÌÉúÎ°ú ÌåêÎã®ÌïòÏó¨ Î∞±Î∂ÑÏú®Î°ú Î≥ÄÌôò
                                        rate_val = (
                                            float(cell_value) * 100
                                            if float(cell_value) <= 1
                                            else float(cell_value)
                                        )
                                        monthly_rates.append(rate_val)
                                    else:
                                        monthly_rates.append(0)
                                else:
                                    monthly_rates.append(0)

                            suppliers_monthly[supplier_name] = monthly_rates

                        # Îã§Ïùå Ïô∏Ï£ºÏÇ¨Î°ú Ïù¥Îèô (ÎπÑÏú® Ìñâ Í±¥ÎÑàÎõ∞Í∏∞)
                        idx += 2
                    else:
                        idx += 1

            logger.info(
                f"üìä Ï†úÏ°∞ÌíàÏßà Ïô∏Ï£ºÏÇ¨Î≥Ñ ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú ÏôÑÎ£å: {len(suppliers_monthly)}Í∞ú ÏóÖÏ≤¥"
            )

            return {"months": months, "suppliers_monthly": suppliers_monthly}

        except Exception as e:
            logger.error(f"‚ùå Ï†úÏ°∞ÌíàÏßà Ïô∏Ï£ºÏÇ¨Î≥Ñ ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú Ïã§Ìå®: {e}")
            flush_log(logger)
            raise

    def extract_quality_supplier_quarterly_data(self) -> Dict:
        """Ï†úÏ°∞ÌíàÏßà Ïô∏Ï£ºÏÇ¨Î≥Ñ Î∂ÑÍ∏∞Î≥Ñ Î∂àÎüâÎ•† Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú"""
        try:
            logger.info("üìä Ï†úÏ°∞ÌíàÏßà Ïô∏Ï£ºÏÇ¨Î≥Ñ Î∂ÑÍ∏∞Î≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú ÏãúÏûë...")

            # ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞Î•º Î∂ÑÍ∏∞Î≥ÑÎ°ú Í∑∏Î£πÌôî
            monthly_data = self.extract_quality_supplier_monthly_data()

            # Î∂ÑÍ∏∞Î≥Ñ Í∑∏Î£πÌôî (1-3Ïõî: 1Î∂ÑÍ∏∞, 4-6Ïõî: 2Î∂ÑÍ∏∞, 7-9Ïõî: 3Î∂ÑÍ∏∞, 10-12Ïõî: 4Î∂ÑÍ∏∞)
            quarters = []
            suppliers_quarterly = {}

            # ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞Î•º Î∂ÑÍ∏∞Î≥ÑÎ°ú Î≥ÄÌôò
            months = monthly_data["months"]
            month_to_quarter = {}

            for month in months:
                month_num = int(month.replace("Ïõî", ""))
                if month_num in [1, 2, 3]:
                    quarter = "1Î∂ÑÍ∏∞"
                elif month_num in [4, 5, 6]:
                    quarter = "2Î∂ÑÍ∏∞"
                elif month_num in [7, 8, 9]:
                    quarter = "3Î∂ÑÍ∏∞"
                else:
                    quarter = "4Î∂ÑÍ∏∞"

                month_to_quarter[month] = quarter
                if quarter not in quarters:
                    quarters.append(quarter)

            # Í∞Å Ïô∏Ï£ºÏÇ¨Î≥ÑÎ°ú Î∂ÑÍ∏∞Î≥Ñ Îç∞Ïù¥ÌÑ∞ Í≥ÑÏÇ∞
            for supplier, monthly_rates in monthly_data["suppliers_monthly"].items():
                quarterly_rates = []

                for quarter in quarters:
                    # Ìï¥Îãπ Î∂ÑÍ∏∞Ïùò ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞ ÌèâÍ∑† Í≥ÑÏÇ∞
                    quarter_months = [
                        i
                        for i, month in enumerate(months)
                        if month_to_quarter[month] == quarter
                    ]
                    if quarter_months:
                        quarter_avg = sum(
                            monthly_rates[i] for i in quarter_months
                        ) / len(quarter_months)
                        quarterly_rates.append(round(quarter_avg, 1))
                    else:
                        quarterly_rates.append(0)

                suppliers_quarterly[supplier] = quarterly_rates

            logger.info(
                f"üìä Ï†úÏ°∞ÌíàÏßà Ïô∏Ï£ºÏÇ¨Î≥Ñ Î∂ÑÍ∏∞Î≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú ÏôÑÎ£å: {len(suppliers_quarterly)}Í∞ú ÏóÖÏ≤¥, {len(quarters)}Í∞ú Î∂ÑÍ∏∞"
            )

            return {"quarters": quarters, "suppliers_quarterly": suppliers_quarterly}

        except Exception as e:
            logger.error(f"‚ùå Ï†úÏ°∞ÌíàÏßà Ïô∏Ï£ºÏÇ¨Î≥Ñ Î∂ÑÍ∏∞Î≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú Ïã§Ìå®: {e}")
            flush_log(logger)
            raise

    def create_quality_monthly_trend_chart(self) -> go.Figure:
        """Ï†úÏ°∞ÌíàÏßà ÏõîÎ≥Ñ Ìä∏Î†åÎìú Ï∞®Ìä∏ ÏÉùÏÑ± (Í∞ÄÏïïÍ≤ÄÏÇ¨ÏôÄ ÏôÑÏ†ÑÌûà ÎèôÏùºÌïú Íµ¨Ï°∞)"""
        try:
            logger.info("üìä Ï†úÏ°∞ÌíàÏßà ÏõîÎ≥Ñ Ìä∏Î†åÎìú Ï∞®Ìä∏ ÏÉùÏÑ± Ï§ë...")

            monthly_data = self.extract_quality_monthly_data()

            # Ïù¥Ï§ë Ï∂ï Ï∞®Ìä∏ ÏÉùÏÑ± (Í∞ÄÏïïÍ≤ÄÏÇ¨ÏôÄ ÏôÑÏ†ÑÌûà ÎèôÏùºÌïú Íµ¨Ï°∞)
            fig = make_subplots(
                rows=1,
                cols=1,
                specs=[[{"secondary_y": True}]],
            )

            # Í≤ÄÏÇ¨ CHÏàò (ÎßâÎåÄ Ï∞®Ìä∏)
            fig.add_trace(
                go.Bar(
                    x=monthly_data["months"],
                    y=monthly_data["ch_counts"],
                    name="Í≤ÄÏÇ¨ CHÏàò",
                    marker_color="rgba(54, 162, 235, 0.6)",
                    text=monthly_data["ch_counts"],
                    textposition="auto",
                ),
                secondary_y=False,
            )

            # Î∂àÎüâ Í±¥Ïàò (ÎßâÎåÄ Ï∞®Ìä∏)
            fig.add_trace(
                go.Bar(
                    x=monthly_data["months"],
                    y=monthly_data["defect_counts"],
                    name="Î∂àÎüâ Í±¥Ïàò",
                    marker_color="rgba(255, 99, 132, 0.8)",
                    text=monthly_data["defect_counts"],
                    textposition="auto",
                ),
                secondary_y=False,
            )

            # Î∂àÎüâÎ•† (ÏÑ† Ï∞®Ìä∏)
            fig.add_trace(
                go.Scatter(
                    x=monthly_data["months"],
                    y=monthly_data["defect_rates"],
                    mode="lines+markers",
                    name="CHÎãπ Î∂àÎüâÎ•† (%)",
                    line=dict(color="rgba(54, 162, 235, 1)", width=3),
                    marker=dict(size=8),
                    text=[f"{rate:.1f}%" for rate in monthly_data["defect_rates"]],
                    textposition="top center",
                ),
                secondary_y=True,
            )

            # Ï∂ï Ï†úÎ™© ÏÑ§Ï†ï
            fig.update_xaxes(title_text="Ïõî")
            fig.update_yaxes(
                title_text="Í±¥Ïàò (Í≤ÄÏÇ¨ CHÏàò / Î∂àÎüâ Í±¥Ïàò)", secondary_y=False
            )
            fig.update_yaxes(title_text="CHÎãπ Î∂àÎüâÎ•† (%)", secondary_y=True)

            # Î†àÏù¥ÏïÑÏõÉ ÏÑ§Ï†ï
            fig.update_layout(
                title={
                    "text": "2025ÎÖÑ Ï†úÏ°∞ÌíàÏßà Î∂àÎüâ ÏõîÎ≥Ñ Ìä∏Î†åÎìú",
                    "x": 0.5,
                    "xanchor": "center",
                    "font": {"size": 20, "family": "Arial, sans-serif"},
                },
                xaxis=dict(tickangle=0, tickfont=dict(size=12)),
                legend=dict(
                    orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1
                ),
                height=500,
                template="plotly_white",
            )

            logger.info("‚úÖ Ï†úÏ°∞ÌíàÏßà ÏõîÎ≥Ñ Ìä∏Î†åÎìú Ï∞®Ìä∏ ÏÉùÏÑ± ÏôÑÎ£å")
            flush_log(logger)

            return fig

        except Exception as e:
            logger.error(f"‚ùå Ï†úÏ°∞ÌíàÏßà ÏõîÎ≥Ñ Ìä∏Î†åÎìú Ï∞®Ìä∏ ÏÉùÏÑ± Ïã§Ìå®: {e}")
            flush_log(logger)
            raise

    def create_quality_action_integrated_chart(self) -> go.Figure:
        """Ï†úÏ°∞ÌíàÏßà Ï°∞Ïπò Ïú†ÌòïÎ≥Ñ ÌÜµÌï© Ï∞®Ìä∏ ÏÉùÏÑ± (Î∂àÎüâÎÇ¥Ïó≠ Í∏∞Î∞ò, Í∞ÄÏïïÍ≤ÄÏÇ¨ÏôÄ ÎèôÏùºÌïú Î∞©Ïãù)"""
        try:
            logger.info("üìä Ï†úÏ°∞ÌíàÏßà Ï°∞ÏπòÏú†ÌòïÎ≥Ñ ÌÜµÌï© Ï∞®Ìä∏ ÏÉùÏÑ± (Î∂àÎüâÎÇ¥Ïó≠ Í∏∞Î∞ò)")

            # Ï†úÏ°∞ÌíàÏßà Î∂àÎüâÎÇ¥Ïó≠ Îç∞Ïù¥ÌÑ∞ Î°úÎìú
            if (
                not hasattr(self, "quality_defect_data")
                or self.quality_defect_data is None
            ):
                self.quality_defect_data = self.load_quality_defect_data()

            df = self.quality_defect_data.copy()
            df["Î∞úÏÉùÏùº_pd"] = pd.to_datetime(df["Î∞úÏÉùÏùº"], errors="coerce")
            df["Î∞úÏÉùÏõî"] = df["Î∞úÏÉùÏùº_pd"].dt.to_period("M")
            df["Î∞úÏÉùÎ∂ÑÍ∏∞"] = df["Î∞úÏÉùÏùº_pd"].dt.to_period("Q")

            # Ïú†Ìö®Ìïú Îç∞Ïù¥ÌÑ∞Îßå ÌïÑÌÑ∞ÎßÅ
            df_valid = df.dropna(subset=["ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©", "Î∞úÏÉùÏùº_pd"])
            logger.info(f"üìä Ï†úÏ°∞ÌíàÏßà Ïú†Ìö®Ìïú Î∂àÎüâÎÇ¥Ïó≠ Îç∞Ïù¥ÌÑ∞: {len(df_valid)}Í±¥")

            # Ï†ÑÏ≤¥Î∂ÑÌè¨Ïö© Îç∞Ïù¥ÌÑ∞ (ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö© Ïπ¥Ïö¥Ìä∏)
            action_counts = df_valid["ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©"].value_counts()
            logger.info(f"üìä Ï†úÏ°∞ÌíàÏßà Ï°∞ÏπòÏú†ÌòïÎ≥Ñ Ïπ¥Ïö¥Ìä∏: {dict(action_counts.head())}")

            # TOP3 Ï°∞ÏπòÏú†Ìòï Ï∂îÏ∂ú
            top_actions = action_counts.head(3).index.tolist()
            df_top3 = df_valid[df_valid["ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©"].isin(top_actions)]
            logger.info(f"üìä Ï†úÏ°∞ÌíàÏßà TOP3 Ï°∞ÏπòÏú†Ìòï: {top_actions}")

            # Î©îÏù∏ Ï∞®Ìä∏ ÏÉùÏÑ±
            fig = go.Figure()

            # ÏÉâÏÉÅ Ï†ïÏùò
            colors = [
                "#FF6B6B",
                "#4ECDC4",
                "#45B7D1",
                "#96CEB4",
                "#FFEAA7",
                "#DDA0DD",
                "#FF8A80",
                "#81C784",
            ]

            # 1. Ï†ÑÏ≤¥ Î∂ÑÌè¨ ÌååÏù¥Ï∞®Ìä∏ (Í∏∞Î≥∏ ÌëúÏãú)
            fig.add_trace(
                go.Pie(
                    labels=action_counts.index.tolist(),
                    values=action_counts.values.tolist(),
                    hole=0.4,
                    textinfo="label+percent+value",
                    textposition="outside",
                    textfont=dict(size=12),
                    marker_colors=colors[: len(action_counts)],
                    pull=[0.05, 0, 0, 0, 0, 0.1],
                    texttemplate="%{label}<br>%{value}Í±¥ (%{percent})",
                    hovertemplate="<b>%{label}</b><br>Í±¥Ïàò: %{value}<br>ÎπÑÏú®: %{percent}<extra></extra>",
                    visible=True,
                    showlegend=True,
                    name="Ï†ÑÏ≤¥Î∂ÑÌè¨",
                )
            )

            # 2. Î∂ÑÍ∏∞Î≥Ñ ÎπÑÍµê (TOP3) - ÎßâÎåÄ Ï∞®Ìä∏
            quarterly_data = (
                df_top3.groupby(["Î∞úÏÉùÎ∂ÑÍ∏∞", "ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©"])
                .size()
                .unstack(fill_value=0)
            )

            # Î∂ÑÍ∏∞ Ïù¥Î¶ÑÏùÑ ÌïúÍµ≠Ïñ¥Î°ú Î≥ÄÌôò
            quarter_names = []
            for quarter in quarterly_data.index:
                quarter_str = str(quarter)
                try:
                    year = quarter_str[:4]
                    q_num = quarter_str[-1]
                    quarter_names.append(f"{year}ÎÖÑ {q_num}Î∂ÑÍ∏∞")
                except:
                    quarter_names.append(quarter_str)

            # Î∂ÑÍ∏∞Î≥Ñ ÎπÑÍµêÏö© ÎßâÎåÄ Ï∞®Ìä∏ Ï∂îÍ∞Ä
            for i, action in enumerate(top_actions):
                if action in quarterly_data.columns:
                    # Í∞Å Î∂ÑÍ∏∞+Ï°∞ÏπòÏú†Ìòï Ï°∞Ìï©Ïùò Ï£ºÏöî Î∂ÄÌíàÎ™Ö Ï∂îÏ∂ú (hoverÏö©)
                    hover_texts = []
                    for quarter_period in quarterly_data.index:
                        quarter_data_filtered = df_top3[
                            (df_top3["Î∞úÏÉùÎ∂ÑÍ∏∞"] == quarter_period)
                            & (df_top3["ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©"] == action)
                        ]
                        top_parts = (
                            quarter_data_filtered["Î∂ÄÌíàÎ™Ö"]
                            .value_counts()
                            .head(5)
                            .index.tolist()
                        )
                        hover_text = (
                            f"Ï£ºÏöîÎ∂ÄÌíà: {', '.join(top_parts[:3])}"
                            if top_parts
                            else "Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå"
                        )
                        hover_texts.append(hover_text)

                    fig.add_trace(
                        go.Bar(
                            x=quarter_names,
                            y=quarterly_data[action].values,
                            name=action,
                            marker_color=colors[i % len(colors)],
                            hovertemplate=f"<b>{action}</b><br>"
                            + "Î∂ÑÍ∏∞: %{x}<br>"
                            + "Í±¥Ïàò: %{y}<br>"
                            + "%{customdata}<extra></extra>",
                            customdata=hover_texts,
                            visible=False,  # Í∏∞Î≥∏ Ïà®ÍπÄ
                        )
                    )

            # 3. ÏõîÎ≥Ñ Ï∂îÏù¥ (TOP3) - ÎùºÏù∏ Ï∞®Ìä∏
            monthly_data = (
                df_top3.groupby(["Î∞úÏÉùÏõî", "ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©"]).size().unstack(fill_value=0)
            )

            # Ïõî Ïù¥Î¶ÑÏùÑ ÌïúÍµ≠Ïñ¥Î°ú Î≥ÄÌôò
            month_names = []
            for month in monthly_data.index:
                month_str = str(month)
                try:
                    month_num = int(month_str.split("-")[1])
                    month_names.append(f"{month_num}Ïõî")
                except:
                    month_names.append(month_str)

            # ÏõîÎ≥Ñ Ï∂îÏù¥Ïö© ÎùºÏù∏ Ï∞®Ìä∏ Ï∂îÍ∞Ä
            for i, action in enumerate(top_actions):
                if action in monthly_data.columns:
                    fig.add_trace(
                        go.Scatter(
                            x=month_names,
                            y=monthly_data[action].values,
                            mode="lines+markers",
                            name=action,
                            line=dict(color=colors[i % len(colors)], width=3),
                            marker=dict(size=8),
                            hovertemplate=f"<b>{action}</b><br>"
                            + "Ïõî: %{x}<br>"
                            + "Í±¥Ïàò: %{y}<extra></extra>",
                            visible=False,  # Í∏∞Î≥∏ Ïà®ÍπÄ
                        )
                    )

            # ÎìúÎ°≠Îã§Ïö¥ Î©îÎâ¥ Íµ¨ÏÑ±
            dropdown_buttons = []

            # Ï†ÑÏ≤¥ Î∂ÑÌè¨ Î≤ÑÌäº
            pie_visibility = [True] + [False] * (len(fig.data) - 1)
            dropdown_buttons.append(
                dict(
                    label="Ï†ÑÏ≤¥ Î∂ÑÌè¨",
                    method="update",
                    args=[
                        {"visible": pie_visibility},
                        {
                            "title": "Ï†úÏ°∞ÌíàÏßà Ï°∞ÏπòÏú†ÌòïÎ≥Ñ Ï†ÑÏ≤¥ Î∂ÑÌè¨",
                            "xaxis": {
                                "visible": False,
                                "showgrid": False,
                                "zeroline": False,
                            },
                            "yaxis": {
                                "visible": False,
                                "showgrid": False,
                                "zeroline": False,
                            },
                        },
                    ],
                )
            )

            # Î∂ÑÍ∏∞Î≥Ñ ÎπÑÍµê Î≤ÑÌäº
            quarterly_visibility = [False] + [
                True if i < len(top_actions) else False
                for i in range(len(fig.data) - 1)
            ]
            dropdown_buttons.append(
                dict(
                    label="Î∂ÑÍ∏∞Î≥Ñ ÎπÑÍµê (TOP3)",
                    method="update",
                    args=[
                        {"visible": quarterly_visibility},
                        {
                            "title": "Ï†úÏ°∞ÌíàÏßà Ï°∞ÏπòÏú†ÌòïÎ≥Ñ Î∂ÑÍ∏∞Î≥Ñ ÎπÑÍµê (TOP3)",
                            "xaxis": {"title": "Î∂ÑÍ∏∞", "visible": True},
                            "yaxis": {"title": "Í±¥Ïàò", "visible": True},
                        },
                    ],
                )
            )

            # ÏõîÎ≥Ñ Ï∂îÏù¥ Î≤ÑÌäº
            monthly_visibility = [False] * (1 + len(top_actions)) + [True] * len(
                top_actions
            )
            dropdown_buttons.append(
                dict(
                    label="ÏõîÎ≥Ñ Ï∂îÏù¥ (TOP3)",
                    method="update",
                    args=[
                        {"visible": monthly_visibility},
                        {
                            "title": "Ï†úÏ°∞ÌíàÏßà Ï°∞ÏπòÏú†ÌòïÎ≥Ñ ÏõîÎ≥Ñ Ï∂îÏù¥ (TOP3)",
                            "xaxis": {"title": "Ïõî", "visible": True},
                            "yaxis": {"title": "Í±¥Ïàò", "visible": True},
                        },
                    ],
                )
            )

            # Î†àÏù¥ÏïÑÏõÉ ÏÑ§Ï†ï
            fig.update_layout(
                updatemenus=[
                    {
                        "buttons": dropdown_buttons,
                        "direction": "down",
                        "showactive": True,
                        "x": 0.1,
                        "xanchor": "left",
                        "y": 1.15,
                        "yanchor": "top",
                    }
                ],
                title={
                    "text": "Ï†úÏ°∞ÌíàÏßà Ï°∞ÏπòÏú†ÌòïÎ≥Ñ Ï†ÑÏ≤¥ Î∂ÑÌè¨",
                    "x": 0.5,
                    "xanchor": "center",
                    "font": {"size": 18, "family": "Arial, sans-serif"},
                },
                height=500,
                margin=dict(l=50, r=50, t=120, b=50),
                template="plotly_white",
                xaxis=dict(visible=False, showgrid=False, zeroline=False),
                yaxis=dict(visible=False, showgrid=False, zeroline=False),
                legend=dict(
                    orientation="v", yanchor="middle", y=0.5, xanchor="left", x=1.05
                ),
            )

            logger.info("‚úÖ Ï†úÏ°∞ÌíàÏßà Ï°∞ÏπòÏú†ÌòïÎ≥Ñ ÌÜµÌï© Ï∞®Ìä∏ ÏÉùÏÑ± ÏôÑÎ£å (Î∂àÎüâÎÇ¥Ïó≠ Í∏∞Î∞ò)")
            return fig

        except Exception as e:
            logger.error(f"‚ùå Ï†úÏ°∞ÌíàÏßà Ï°∞Ïπò Ïú†ÌòïÎ≥Ñ ÌÜµÌï© Ï∞®Ìä∏ ÏÉùÏÑ± Ïã§Ìå®: {e}")
            flush_log(logger)
            raise

    def create_quality_supplier_integrated_chart(self) -> go.Figure:
        """Ï†úÏ°∞ÌíàÏßà Ïô∏Ï£ºÏÇ¨Î≥Ñ ÌÜµÌï© Ï∞®Ìä∏ ÏÉùÏÑ± (Í∞ÄÏïïÍ≤ÄÏÇ¨ÏôÄ ÎèôÏùºÌïú ÎìúÎ°≠Îã§Ïö¥ Î∞©Ïãù)"""
        try:
            logger.info("üìä Ï†úÏ°∞ÌíàÏßà Ïô∏Ï£ºÏÇ¨Î≥Ñ ÌÜµÌï© Ï∞®Ìä∏ ÏÉùÏÑ± Ï§ë...")

            # 1. Ï†ÑÏ≤¥ ÌòÑÌô© Ï∞®Ìä∏
            supplier_data = self.extract_quality_supplier_data()

            # 2. Î∂ÑÍ∏∞Î≥Ñ Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞
            quarterly_data = self.extract_quality_supplier_quarterly_data()

            # 3. ÏõîÎ≥Ñ Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞
            monthly_data = self.extract_quality_supplier_monthly_data()

            # Î©îÏù∏ Ï∞®Ìä∏ ÏÉùÏÑ± (Í∏∞Î≥∏: Ï†ÑÏ≤¥ ÌòÑÌô©)
            fig = go.Figure()

            # ÏÉâÏÉÅ Ï†ïÏùò (6Í∞ú Ïô∏Ï£ºÏÇ¨Ïö©)
            colors = ["#4CAF50", "#2196F3", "#FF9800", "#9C27B0", "#F44336", "#607D8B"]

            # 1. Ï†ÑÏ≤¥ ÌòÑÌô© Ï∞®Ìä∏ (Í∏∞Î≥∏ ÌëúÏãú)
            for i, (supplier, count, rate) in enumerate(
                zip(
                    supplier_data["suppliers"],
                    supplier_data["supplier_counts"],
                    supplier_data["supplier_rates"],
                )
            ):
                fig.add_trace(
                    go.Bar(
                        x=[supplier],
                        y=[count],
                        name=supplier,
                        marker_color=colors[i % len(colors)],
                        text=[f"{count}Í±¥<br>({rate:.1f}%)"],
                        textposition="outside",
                        textfont=dict(size=10),
                        visible=True,  # Í∏∞Î≥∏ ÌëúÏãú
                    )
                )

            # 2. Î∂ÑÍ∏∞Î≥Ñ Ï∞®Ìä∏ (Ïà®ÍπÄ)
            for i, (supplier, rates) in enumerate(
                quarterly_data["suppliers_quarterly"].items()
            ):
                for j, (quarter, rate) in enumerate(
                    zip(quarterly_data["quarters"], rates)
                ):
                    fig.add_trace(
                        go.Bar(
                            x=[quarter],
                            y=[rate],
                            name=supplier,
                            marker_color=colors[i % len(colors)],
                            text=[f"{rate}%" if rate > 0 else ""],
                            textposition="outside",
                            textfont=dict(size=10),
                            visible=False,  # Í∏∞Î≥∏ Ïà®ÍπÄ
                            showlegend=False if j > 0 else True,  # Ï≤´ Î≤àÏß∏Îßå Î≤îÎ°Ä ÌëúÏãú
                        )
                    )

            # 3. ÏõîÎ≥Ñ Ï∞®Ìä∏ (ÏÑ† Í∑∏ÎûòÌîÑÎ°ú Î≥ÄÍ≤Ω)
            for i, (supplier, rates) in enumerate(
                monthly_data["suppliers_monthly"].items()
            ):
                fig.add_trace(
                    go.Scatter(
                        x=monthly_data["months"],
                        y=rates,
                        mode="lines+markers",
                        name=supplier,
                        line=dict(color=colors[i % len(colors)], width=3),
                        marker=dict(size=8, color=colors[i % len(colors)]),
                        text=[f"{rate:.1f}%" if rate > 0 else "" for rate in rates],
                        textposition="top center",
                        textfont=dict(size=10),
                        visible=False,  # Í∏∞Î≥∏ Ïà®ÍπÄ
                        showlegend=True,
                    )
                )

            # ÎìúÎ°≠Îã§Ïö¥ Î©îÎâ¥ ÏÑ§Ï†ï
            total_suppliers = len(supplier_data["suppliers"])
            quarterly_traces = len(quarterly_data["suppliers_quarterly"]) * len(
                quarterly_data["quarters"]
            )
            monthly_traces = len(
                monthly_data["suppliers_monthly"]
            )  # ÏÑ† Í∑∏ÎûòÌîÑÎ°ú Î≥ÄÍ≤ΩÎêòÏñ¥ Ïô∏Ï£ºÏÇ¨Î≥Ñ 1Í∞úÏî©

            # Í∞ÄÏãúÏÑ± ÏÑ§Ï†ï
            visibility_overall = [True] * total_suppliers + [False] * (
                quarterly_traces + monthly_traces
            )
            visibility_quarterly = (
                [False] * total_suppliers
                + [True] * quarterly_traces
                + [False] * monthly_traces
            )
            visibility_monthly = (
                [False] * total_suppliers
                + [False] * quarterly_traces
                + [True] * monthly_traces
            )

            # ÎìúÎ°≠Îã§Ïö¥ Î©îÎâ¥ Íµ¨ÏÑ±
            fig.update_layout(
                updatemenus=[
                    {
                        "buttons": [
                            {
                                "label": "Ï†ÑÏ≤¥ ÌòÑÌô©",
                                "method": "update",
                                "args": [
                                    {"visible": visibility_overall},
                                    {
                                        "title": {
                                            "text": "Ï†úÏ°∞ÌíàÏßà Ïô∏Ï£ºÏÇ¨Î≥Ñ Î∂àÎüâ ÌòÑÌô©",
                                            "x": 0.5,
                                            "xanchor": "center",
                                        },
                                        "xaxis": {"title": "Ïô∏Ï£ºÏÇ¨", "visible": True},
                                        "yaxis": {
                                            "title": "Î∂àÎüâ Í±¥Ïàò",
                                            "visible": True,
                                        },
                                    },
                                ],
                            },
                            {
                                "label": "Î∂ÑÍ∏∞Î≥Ñ Î∂àÎüâÎ•†",
                                "method": "update",
                                "args": [
                                    {"visible": visibility_quarterly},
                                    {
                                        "title": {
                                            "text": "Ï†úÏ°∞ÌíàÏßà Ïô∏Ï£ºÏÇ¨Î≥Ñ Î∂ÑÍ∏∞Î≥Ñ Î∂àÎüâÎ•†",
                                            "x": 0.5,
                                            "xanchor": "center",
                                        },
                                        "xaxis": {"title": "Î∂ÑÍ∏∞", "visible": True},
                                        "yaxis": {
                                            "title": "Î∂àÎüâÎ•† (%)",
                                            "visible": True,
                                        },
                                    },
                                ],
                            },
                            {
                                "label": "ÏõîÎ≥Ñ Ìä∏Î†åÎìú",
                                "method": "update",
                                "args": [
                                    {"visible": visibility_monthly},
                                    {
                                        "title": {
                                            "text": "Ï†úÏ°∞ÌíàÏßà Ïô∏Ï£ºÏÇ¨Î≥Ñ ÏõîÎ≥Ñ Î∂àÎüâÎ•† Ìä∏Î†åÎìú",
                                            "x": 0.5,
                                            "xanchor": "center",
                                        },
                                        "xaxis": {"title": "Ïõî", "visible": True},
                                        "yaxis": {
                                            "title": "Î∂àÎüâÎ•† (%)",
                                            "visible": True,
                                        },
                                    },
                                ],
                            },
                        ],
                        "direction": "down",
                        "showactive": True,
                        "x": 0.02,
                        "xanchor": "left",
                        "y": 1.15,
                        "yanchor": "top",
                        "bgcolor": "rgba(255, 255, 255, 0.9)",
                        "bordercolor": "rgba(0, 0, 0, 0.2)",
                        "borderwidth": 1,
                        "font": {"size": 12},
                    }
                ],
                title={
                    "text": "Ï†úÏ°∞ÌíàÏßà Ïô∏Ï£ºÏÇ¨Î≥Ñ Î∂àÎüâ ÌòÑÌô©",
                    "x": 0.5,
                    "xanchor": "center",
                    "font": {"size": 20, "family": "Arial, sans-serif"},
                },
                xaxis_title="Ïô∏Ï£ºÏÇ¨",
                yaxis_title="Î∂àÎüâ Í±¥Ïàò",
                height=500,
                template="plotly_white",
                font=dict(family="Arial, sans-serif", size=12),
                legend=dict(
                    orientation="v", yanchor="top", y=1, xanchor="left", x=1.02
                ),
                margin=dict(t=100, b=50, l=50, r=120),
            )

            logger.info("‚úÖ Ï†úÏ°∞ÌíàÏßà Ïô∏Ï£ºÏÇ¨Î≥Ñ ÌÜµÌï© Ï∞®Ìä∏ ÏÉùÏÑ± ÏôÑÎ£å")
            flush_log(logger)

            return fig

        except Exception as e:
            logger.error(f"‚ùå Ï†úÏ°∞ÌíàÏßà Ïô∏Ï£ºÏÇ¨Î≥Ñ ÌÜµÌï© Ï∞®Ìä∏ ÏÉùÏÑ± Ïã§Ìå®: {e}")
            flush_log(logger)
            raise

    def create_quality_part_monthly_chart(self) -> go.Figure:
        """Ï†úÏ°∞ÌíàÏßà Î∂ÄÌíàÎ≥Ñ ÏÉÅÏÑ∏ Î∂ÑÏÑù Ï∞®Ìä∏ ÏÉùÏÑ± (Í∞ÄÏïïÍ≤ÄÏÇ¨ÏôÄ ÏôÑÏ†ÑÌûà ÎèôÏùºÌïú Íµ¨Ï°∞)"""
        try:
            logger.info("üìä Ï†úÏ°∞ÌíàÏßà Î∂ÄÌíàÎ≥Ñ ÏÉÅÏÑ∏ Î∂ÑÏÑù Ï∞®Ìä∏ ÏÉùÏÑ± Ï§ë...")

            if (
                not hasattr(self, "quality_defect_data")
                or self.quality_defect_data is None
            ):
                self.quality_defect_data = self.load_quality_defect_data()

            df = self.quality_defect_data.copy()

            # Î∞úÏÉùÏùºÏùÑ ÎÇ†Ïßú ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
            df["Î∞úÏÉùÏùº_pd"] = pd.to_datetime(df["Î∞úÏÉùÏùº"], errors="coerce")
            df["Î∞úÏÉùÎ∂ÑÍ∏∞"] = df["Î∞úÏÉùÏùº_pd"].dt.to_period("Q")
            df["Î∞úÏÉùÏõî"] = df["Î∞úÏÉùÏùº_pd"].dt.to_period("M")

            # Í∞Å Î∂ÑÍ∏∞Î≥Ñ ÏÉÅÏúÑ 5Í∞ú Î∂ÄÌíà Ï∂îÏ∂ú
            quarters = df["Î∞úÏÉùÎ∂ÑÍ∏∞"].dropna().unique()
            quarterly_top5_data = {}

            for quarter in quarters:
                quarter_data = df[df["Î∞úÏÉùÎ∂ÑÍ∏∞"] == quarter]
                part_counts = quarter_data["Î∂ÄÌíàÎ™Ö"].value_counts().head(5)
                quarterly_top5_data[quarter] = part_counts

            # Ï†ÑÏ≤¥ Í∏∞Í∞Ñ ÏÉÅÏúÑ 3Í∞ú Î∂ÄÌíà (ÏõîÎ≥Ñ Ï∂îÏù¥Ïö©)
            top3_parts = df["Î∂ÄÌíàÎ™Ö"].value_counts().head(3).index.tolist()

            # ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞ ÌïÑÌÑ∞ÎßÅ (TOP3)
            df_top3 = df[df["Î∂ÄÌíàÎ™Ö"].isin(top3_parts)]
            df_top3 = df_top3.dropna(subset=["Î∞úÏÉùÏõî"])

            # ÏõîÎ≥Ñ Î∂ÄÌíàÎ≥Ñ ÏßëÍ≥Ñ
            monthly_top3 = (
                df_top3.groupby(["Î∞úÏÉùÏõî", "Î∂ÄÌíàÎ™Ö"]).size().unstack(fill_value=0)
            )
            months = monthly_top3.index  # months Î≥ÄÏàò Ï∂îÍ∞Ä

            # Ïõî Ïù¥Î¶ÑÏùÑ ÌïúÍµ≠Ïñ¥Î°ú Î≥ÄÌôò
            month_names = []
            for month in monthly_top3.index:
                month_str = str(month)
                try:
                    month_num = int(month_str.split("-")[1])
                    month_names.append(f"{month_num}Ïõî")
                except:
                    month_names.append(month_str)

            # Î∂ÑÍ∏∞ Ïù¥Î¶ÑÏùÑ ÌïúÍµ≠Ïñ¥Î°ú Î≥ÄÌôò
            quarter_names = []
            for quarter in quarters:
                quarter_str = str(quarter)
                if "Q1" in quarter_str:
                    quarter_names.append("1Î∂ÑÍ∏∞")
                elif "Q2" in quarter_str:
                    quarter_names.append("2Î∂ÑÍ∏∞")
                elif "Q3" in quarter_str:
                    quarter_names.append("3Î∂ÑÍ∏∞")
                elif "Q4" in quarter_str:
                    quarter_names.append("4Î∂ÑÍ∏∞")
                else:
                    quarter_names.append(quarter_str)

            # Î©îÏù∏ Ï∞®Ìä∏ ÏÉùÏÑ±
            fig = go.Figure()

            # ÏÉâÏÉÅ Ï†ïÏùò
            colors = ["#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", "#FFEAA7"]

            # 0. Ï†ÑÏ≤¥ Î∂ÑÌè¨ ÌååÏù¥Ï∞®Ìä∏ (TOP10 + Í∏∞ÌÉÄ)
            part_counts = df["Î∂ÄÌíàÎ™Ö"].value_counts()

            # TOP10 Ï∂îÏ∂ú
            top10_parts = part_counts.head(10)
            other_count = part_counts.iloc[10:].sum() if len(part_counts) > 10 else 0

            # TOP10 + Í∏∞ÌÉÄÎ°ú Íµ¨ÏÑ±
            if other_count > 0:
                pie_labels = list(top10_parts.index) + ["Í∏∞ÌÉÄ"]
                pie_values = list(top10_parts.values) + [other_count]
            else:
                pie_labels = list(top10_parts.index)
                pie_values = list(top10_parts.values)

            fig.add_trace(
                go.Pie(
                    labels=pie_labels,
                    values=pie_values,
                    hole=0.4,
                    textinfo="label+percent+value",
                    textposition="outside",
                    textfont=dict(size=12),
                    marker_colors=colors[: len(pie_labels)],
                    pull=[
                        0.05,
                        0,
                        0,
                        0,
                        0,
                        0.1,
                        0,
                        0,
                        0,
                        0,
                        0.05,
                    ],  # Ï≤´ Î≤àÏß∏ÏôÄ ÎßàÏßÄÎßâ(Í∏∞ÌÉÄ) Í∞ïÏ°∞
                    texttemplate="%{label}<br>%{value}Í±¥ (%{percent})",
                    hovertemplate="<b>%{label}</b><br>Í±¥Ïàò: %{value}<br>ÎπÑÏú®: %{percent}<extra></extra>",
                    visible=True,  # Í∏∞Î≥∏ ÌëúÏãú
                    showlegend=True,
                )
            )

            # 1. Í∞Å Î∂ÑÍ∏∞Î≥Ñ TOP5 Î∂ÄÌíà ÎßâÎåÄ Ï∞®Ìä∏
            for q_idx, quarter in enumerate(quarters):
                top5_data = quarterly_top5_data[quarter]

                for p_idx, (part, count) in enumerate(top5_data.items()):
                    # Ìï¥Îãπ Î∂ÑÍ∏∞, Ìï¥Îãπ Î∂ÄÌíàÏùò ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Ï∂îÏ∂ú
                    quarter_part_df = df[
                        (df["Î∞úÏÉùÎ∂ÑÍ∏∞"] == quarter) & (df["Î∂ÄÌíàÎ™Ö"] == part)
                    ]

                    # ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©Í≥º Î∂àÎüâÏúÑÏπò Ï†ïÎ≥¥ ÏàòÏßë
                    action_details = (
                        quarter_part_df["ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©"].dropna().unique()[:5]
                    )  # ÏµúÎåÄ 5Í∞ú
                    location_details = (
                        quarter_part_df["Î∂àÎüâÏúÑÏπò"].dropna().unique()[:5]
                    )  # ÏµúÎåÄ 5Í∞ú

                    # hover text ÏÉùÏÑ±
                    hover_text = f"<b>{part}</b><br>"
                    hover_text += f"Î∂àÎüâ Í±¥Ïàò: {count}Í±¥<br><br>"

                    if len(action_details) > 0:
                        hover_text += "<b>Ï£ºÏöî Ï°∞ÏπòÎÇ¥Ïö©:</b><br>"
                        for i, action in enumerate(action_details, 1):
                            hover_text += f"{i}. {action}<br>"
                        hover_text += "<br>"

                    if len(location_details) > 0:
                        hover_text += "<b>Ï£ºÏöî Î∂àÎüâÏúÑÏπò:</b><br>"
                        for i, location in enumerate(location_details, 1):
                            hover_text += f"{i}. {location}<br>"

                    fig.add_trace(
                        go.Bar(
                            x=[part],
                            y=[count],
                            name=part,
                            marker_color=colors[p_idx % len(colors)],
                            text=[count],
                            textposition="outside",
                            textfont=dict(size=12),
                            hovertemplate=f"{hover_text}<extra></extra>",
                            visible=False,  # ÌååÏù¥Ï∞®Ìä∏Í∞Ä Í∏∞Î≥∏Ïù¥ÎØÄÎ°ú Î™®Îì† ÎßâÎåÄÏ∞®Ìä∏Îäî Ïà®ÍπÄ
                            showlegend=False,
                        )
                    )

            # 2. ÏõîÎ≥Ñ Ï∂îÏù¥ (ÏÑ† Í∑∏ÎûòÌîÑ, Ïà®ÍπÄ)
            for p_idx, part in enumerate(top3_parts):
                if part in monthly_top3.columns:
                    # Í∞Å ÏõîÎ≥ÑÎ°ú hover Ï†ïÎ≥¥ ÏÉùÏÑ±
                    hover_texts = []
                    for m_idx, month in enumerate(months):
                        month_name = month_names[m_idx]
                        month_count = monthly_top3[part].values[m_idx]

                        # Ìï¥Îãπ Ïõî, Ìï¥Îãπ Î∂ÄÌíàÏùò ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Ï∂îÏ∂ú
                        month_part_df = df[
                            (df["Î∞úÏÉùÏõî"] == month) & (df["Î∂ÄÌíàÎ™Ö"] == part)
                        ]

                        # ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©Í≥º Î∂àÎüâÏúÑÏπò Ï†ïÎ≥¥ ÏàòÏßë
                        action_details = (
                            month_part_df["ÏÉÅÏÑ∏Ï°∞ÏπòÎÇ¥Ïö©"].dropna().unique()[:3]
                        )  # ÏµúÎåÄ 3Í∞ú
                        location_details = (
                            month_part_df["Î∂àÎüâÏúÑÏπò"].dropna().unique()[:3]
                        )  # ÏµúÎåÄ 3Í∞ú

                        # hover text ÏÉùÏÑ±
                        hover_text = f"<b>{month_name}: {part}</b><br>"
                        hover_text += f"Î∂àÎüâ Í±¥Ïàò: {month_count}Í±¥<br><br>"

                        if len(action_details) > 0:
                            hover_text += "<b>Ï£ºÏöî Ï°∞ÏπòÎÇ¥Ïö©:</b><br>"
                            for i, action in enumerate(action_details, 1):
                                hover_text += f"{i}. {action}<br>"
                            hover_text += "<br>"

                        if len(location_details) > 0:
                            hover_text += "<b>Ï£ºÏöî Î∂àÎüâÏúÑÏπò:</b><br>"
                            for i, location in enumerate(location_details, 1):
                                hover_text += f"{i}. {location}<br>"

                        hover_texts.append(hover_text)

                    fig.add_trace(
                        go.Scatter(
                            x=month_names,
                            y=monthly_top3[part].values,
                            mode="lines+markers",
                            name=part,
                            line=dict(color=colors[p_idx % len(colors)], width=3),
                            marker=dict(size=8),
                            text=monthly_top3[part].values,
                            textposition="top center",
                            textfont=dict(size=10),
                            customdata=hover_texts,
                            hovertemplate="%{customdata}<extra></extra>",
                            visible=False,  # Í∏∞Î≥∏Ï†ÅÏúºÎ°ú Ïà®ÍπÄ
                            showlegend=False,
                        )
                    )

            # ÎìúÎ°≠Îã§Ïö¥ Î©îÎâ¥ Î≤ÑÌäº Íµ¨ÏÑ±
            dropdown_buttons = []

            # Ï†ÑÏ≤¥ Î∂ÑÌè¨ Î≤ÑÌäº (Ï≤´ Î≤àÏß∏)
            pie_visibility = [True] + [False] * (len(fig.data) - 1)  # ÌååÏù¥Ï∞®Ìä∏Îßå ÌëúÏãú
            dropdown_buttons.append(
                dict(
                    label="Ï†ÑÏ≤¥ Î∂ÑÌè¨",
                    method="update",
                    args=[
                        {"visible": pie_visibility},
                        {
                            "title": "Ï†úÏ°∞ÌíàÏßà Î∂ÄÌíàÎ≥Ñ Ï†ÑÏ≤¥ Î∂ÑÌè¨ (TOP10)",
                            "xaxis": {
                                "visible": False,
                                "showgrid": False,
                                "zeroline": False,
                            },
                            "yaxis": {
                                "visible": False,
                                "showgrid": False,
                                "zeroline": False,
                            },
                        },
                    ],
                )
            )

            # Í∞Å Î∂ÑÍ∏∞Î≥Ñ Î≤ÑÌäº
            for q_idx, quarter in enumerate(quarters):
                quarter_name = quarter_names[q_idx]

                # Ìï¥Îãπ Î∂ÑÍ∏∞Ïùò traceÎßå Î≥¥Ïù¥ÎèÑÎ°ù ÏÑ§Ï†ï
                visibility = [False] * len(fig.data)
                start_idx = 1 + q_idx * 5  # ÌååÏù¥Ï∞®Ìä∏(1Í∞ú) + Í∞Å Î∂ÑÍ∏∞Îãπ 5Í∞ú Î∂ÄÌíà
                end_idx = start_idx + len(quarterly_top5_data[quarter])

                for i in range(start_idx, min(end_idx, len(fig.data))):
                    if i < len(fig.data):
                        visibility[i] = True

                dropdown_buttons.append(
                    dict(
                        label=f"{quarter_name} TOP5",
                        method="update",
                        args=[
                            {"visible": visibility},
                            {
                                "title": f"{quarter_name} TOP5 Î∂ÄÌíà Î∂àÎüâ ÌòÑÌô©",
                                "xaxis": {"title": "Î∂ÄÌíàÎ™Ö", "visible": True},
                                "yaxis": {"title": "Î∂àÎüâ Í±¥Ïàò", "visible": True},
                            },
                        ],
                    )
                )

            # ÏõîÎ≥Ñ Ï∂îÏù¥ Î≤ÑÌäº
            trend_visibility = [False] * len(fig.data)
            trend_start_idx = (
                1 + len(quarters) * 5
            )  # ÌååÏù¥Ï∞®Ìä∏(1Í∞ú) + Î∂ÑÍ∏∞Î≥Ñ Îç∞Ïù¥ÌÑ∞ Ïù¥ÌõÑ
            for i in range(trend_start_idx, len(fig.data)):
                trend_visibility[i] = True

            dropdown_buttons.append(
                dict(
                    label="ÏõîÎ≥Ñ Ï∂îÏù¥ (TOP3)",
                    method="update",
                    args=[
                        {"visible": trend_visibility},
                        {
                            "title": "Ï†ÑÏ≤¥ Í∏∞Í∞Ñ TOP3 Î∂ÄÌíà ÏõîÎ≥Ñ Ï∂îÏù¥",
                            "xaxis": {"title": "Ïõî", "visible": True},
                            "yaxis": {"title": "Î∂àÎüâ Í±¥Ïàò", "visible": True},
                        },
                    ],
                )
            )

            # Í∏∞Î≥∏ Ï†úÎ™© ÏÑ§Ï†ï (Ï†ÑÏ≤¥ Î∂ÑÌè¨Í∞Ä Í∏∞Î≥∏)
            default_title = "Ï†úÏ°∞ÌíàÏßà Î∂ÄÌíàÎ≥Ñ Ï†ÑÏ≤¥ Î∂ÑÌè¨ (TOP10)"

            # Î†àÏù¥ÏïÑÏõÉ ÏÑ§Ï†ï
            fig.update_layout(
                title=dict(text=default_title, x=0.5, xanchor="center"),
                xaxis=dict(
                    visible=False, showgrid=False, zeroline=False
                ),  # ÌååÏù¥Ï∞®Ìä∏Í∞Ä Í∏∞Î≥∏Ïù¥ÎØÄÎ°ú Ï∂ï Ïà®ÍπÄ
                yaxis=dict(visible=False, showgrid=False, zeroline=False),
                height=500,
                margin=dict(l=50, r=50, t=100, b=50),
                template="plotly_white",
                updatemenus=[
                    dict(
                        buttons=dropdown_buttons,
                        direction="down",
                        pad={"r": 10, "t": 10},
                        showactive=True,
                        x=0.1,
                        xanchor="left",
                        y=1.15,
                        yanchor="top",
                    )
                ],
                showlegend=False,
            )

            logger.info("‚úÖ Ï†úÏ°∞ÌíàÏßà Î∂ÄÌíàÎ≥Ñ ÏÉÅÏÑ∏ Î∂ÑÏÑù Ï∞®Ìä∏ ÏÉùÏÑ± ÏôÑÎ£å")
            flush_log(logger)

            return fig

        except Exception as e:
            logger.error(f"‚ùå Ï†úÏ°∞ÌíàÏßà Î∂ÄÌíàÎ≥Ñ ÏÉÅÏÑ∏ Î∂ÑÏÑù Ï∞®Ìä∏ ÏÉùÏÑ± Ïã§Ìå®: {e}")
            flush_log(logger)
            raise


def main():
    """Îç∞ÏùºÎ¶¨ Ïã§ÌñâÏö© Î©îÏù∏ Ìï®Ïàò"""
    from utils.logger import setup_logger, flush_log

    logger = setup_logger(__name__)

    try:
        logger.info("üåÖ Îç∞ÏùºÎ¶¨ internal.html ÎåÄÏãúÎ≥¥Îìú ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÏûë")

        # DefectVisualizer Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
        visualizer = DefectVisualizer()

        # internal.html ÏÉùÏÑ± Î∞è GitHub ÏóÖÎ°úÎìú
        success = visualizer.save_and_upload_internal_report()

        if success:
            logger.info("‚úÖ Îç∞ÏùºÎ¶¨ internal.html ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å!")
            print("‚úÖ internal.html ÎåÄÏãúÎ≥¥ÎìúÍ∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÏäµÎãàÎã§!")

            # configÏóêÏÑú URL ÎèôÏ†Å ÏÉùÏÑ±
            from config import github_config

            print(
                f"üåê Ï†ëÏÜç URL: https://{github_config.username_2}.github.io/{github_config.repo_2}/public/internal.html"
            )
        else:
            logger.error("‚ùå Îç∞ÏùºÎ¶¨ ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®")
            print("‚ùå ÏóÖÎç∞Ïù¥Ìä∏ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.")

    except Exception as e:
        logger.error(f"‚ùå Îç∞ÏùºÎ¶¨ Ïã§Ìñâ Ï§ë Ïò§Î•ò Î∞úÏÉù: {e}")
        print(f"‚ùå Ïò§Î•ò Î∞úÏÉù: {e}")
    finally:
        flush_log(logger)


if __name__ == "__main__":
    main()
